<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hardster</title>
    <style>
        /* --- STYLES (Largely Unchanged) --- */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap');

        :root {
            --primary: #ff6600; /* Orange */
            --secondary: #00ccff; /* Cyan */
            --bg-dark: #0a0a0a;
            --bg-light: #1a1a1a;
            --text: #ffffff;
            --success: #33cc33; /* Green */
            --danger: #ff3355; /* Red */
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        html, body { /* Ensure body can scroll if content overflows on small screens */
             min-height: 100%;
        }

        body {
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            background-color: var(--bg-dark);
            color: var(--text);
            background-image:
                radial-gradient(circle at 20% 30%, rgba(255, 102, 0, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(0, 204, 255, 0.1) 0%, transparent 40%);
            padding-top: 80px; /* Increased padding to avoid overlap with fixed menu */
            padding-bottom: 50px; /* Add padding at bottom */
        }

        /* --- Collapsible Menu Styles --- */
        #menu-toggle-btn {
            position: fixed; /* Fixed positioning */
            top: 15px;
            right: 15px;
            z-index: 1001; /* Ensure it's above the menu */
            background: rgba(26, 26, 26, 0.8); /* Dark background */
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            width: 45px;
            height: 40px;
            cursor: pointer;
            padding: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            /* Reset button styles */
            margin: 0;
            text-transform: none;
            letter-spacing: normal;
            overflow: visible; /* Ensure spans are visible */
            transition: background 0.3s ease;
        }
        #menu-toggle-btn:hover {
            background: rgba(40, 40, 40, 0.9);
        }
        #menu-toggle-btn span {
            display: block;
            width: 100%;
            height: 3px;
            background-color: var(--secondary); /* Cyan lines */
            border-radius: 1px;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        /* Animation for hamburger to X */
        #menu-toggle-btn[aria-expanded="true"] span:nth-child(1) { transform: translateY(8px) rotate(45deg); }
        #menu-toggle-btn[aria-expanded="true"] span:nth-child(2) { opacity: 0; }
        #menu-toggle-btn[aria-expanded="true"] span:nth-child(3) { transform: translateY(-8px) rotate(-45deg); }

        #collapsible-menu {
            position: fixed; /* Fixed positioning */
            top: 65px; /* Position below the button */
            right: 15px;
            z-index: 1000; /* Below toggle button, above content */
            background-color: rgba(20, 20, 20, 0.95); /* Slightly different dark */
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            width: 220px; /* Adjust as needed */
            overflow: hidden; /* Clip content */
            transition: transform 0.3s ease, opacity 0.3s ease, visibility 0s linear 0.3s; /* Delay visibility change */
            transform-origin: top right;
            transform: scale(0.95); /* Start slightly scaled down */
            opacity: 0;
            visibility: hidden; /* Use visibility for better transition and accessibility */
        }
        #collapsible-menu:not(.hidden) {
            transform: scale(1);
            opacity: 1;
            visibility: visible;
            transition: transform 0.3s ease, opacity 0.3s ease, visibility 0s linear 0s; /* Remove delay when showing */
        }
        #collapsible-menu ul { list-style: none; padding: 10px 0; margin: 0; }
        #collapsible-menu li { margin: 0; }
        #collapsible-menu li a,
        #collapsible-menu li button {
            display: block;
            width: 100%;
            padding: 12px 20px;
            color: var(--text);
            text-decoration: none;
            font-size: 15px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            font-family: 'Roboto', sans-serif; /* Ensure font consistency */
        }
        #collapsible-menu li a:hover,
        #collapsible-menu li button:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--primary); /* Highlight with orange on hover */
        }
        /* Style menu buttons like links */
        #collapsible-menu li button {
            border-radius: 0; margin: 0; box-shadow: none;
            text-transform: none; letter-spacing: normal; font-weight: normal;
        }
        /* Hide the main large login button area (use menu instead) */
        #login-area { display: none !important; }
        /* --- End Menu Styles --- */

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 500px; /* Limit width on larger screens */
            padding: 20px; /* Padding inside the container */
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(28px, 8vw, 36px); /* Responsive font size */
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Standard Box Styling */
        .box {
            text-align: center;
            background-color: rgba(26, 26, 26, 0.85);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .box label {
             color: var(--secondary); margin-bottom: 10px; font-weight: bold;
             display: block; text-align: left;
        }

        /* Status Area Styles */
        #status {
            margin: 15px 0; text-align: center; min-height: 40px; line-height: 1.4;
            font-weight: 300; letter-spacing: 0.5px; background-color: rgba(10, 10, 10, 0.7);
            padding: 12px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%; display: flex; align-items: center; justify-content: center;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            color: var(--text); /* Default text color */
        }
        /* Style types for #status */
        #status.type-info { color: var(--secondary); border-color: rgba(0, 204, 255, 0.2); }
        #status.type-success { color: var(--success); border-color: rgba(51, 204, 51, 0.2); }
        #status.type-error { color: var(--danger); border-color: rgba(255, 51, 85, 0.2); }
        #status.type-shot { /* Renamed from shot-message */
            background-color: rgba(255, 102, 0, 0.3); color: var(--primary);
            font-weight: bold; border-color: rgba(255, 102, 0, 0.4);
        }
        #status.type-pin {
            background-color: rgba(0, 204, 255, 0.15); color: var(--text);
            border-color: rgba(0, 204, 255, 0.3); font-weight: bold;
        }
        #status.type-pin strong { /* Style the PIN itself */
            font-family: 'Orbitron', sans-serif; color: var(--primary); font-size: 1.1em;
            margin-left: 8px; user-select: all; /* Make PIN easily selectable */
        }

        /* General Button Styles */
        button {
            background: linear-gradient(135deg, var(--primary), var(--secondary)); color: white;
            border: none; padding: 14px 28px; border-radius: 30px; font-size: 16px;
            font-weight: bold; cursor: pointer; margin-top: 15px; transition: all 0.3s ease;
            text-transform: uppercase; letter-spacing: 1px; position: relative; overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); display: inline-block; width: auto;
        }
        button.full-width {
            width: 100%; max-width: 350px; display: block;
            margin-left: auto; margin-right: auto;
        }
        button:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 7px 20px rgba(0, 0, 0, 0.4); }
        button:active:not(:disabled) { transform: translateY(1px); }
        button:disabled {
            background: linear-gradient(135deg, #555, #777); cursor: not-allowed;
            transform: none; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); opacity: 0.6;
        }

        /* Input and Select Styles */
        input[type="text"], select {
             background-color: var(--bg-light); color: white; border: 1px solid var(--secondary);
             padding: 12px; border-radius: 8px; width: 100%; margin-top: 8px;
             margin-bottom: 10px; font-size: 14px; outline: none;
        }
        select option { background-color: var(--bg-dark); padding: 8px; }

        /* Loading spinner */
        .loading-spinner { display: inline-block; width: 20px; height: 20px; margin-right: 10px; border: 3px solid rgba(255,255,255,.3); border-radius: 50%; border-top-color: var(--secondary); animation: spin 1s ease-in-out infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* --- Player Setup List --- */
        #player-setup ul { list-style: none; padding: 0; margin-top: 15px; }
        #player-setup li {
            display: flex; justify-content: space-between; align-items: center;
            background-color: rgba(255,255,255,0.05); padding: 8px 12px;
            border-radius: 5px; margin-bottom: 8px; gap: 8px;
        }
        #player-setup .remove-player-btn {
            background: var(--danger); color: white; border: none; border-radius: 50%;
            width: 25px; height: 25px; font-size: 14px; font-weight: bold; cursor: pointer;
            padding: 0; margin: 0; line-height: 25px; text-align: center; flex-shrink: 0;
        }
        #player-setup li span.player-list-name { /* Ensure name takes space */
             flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
             margin-left: 5px; margin-right: 10px; text-align: left;
        }

        /* --- Playback / Song Details --- */
        #playback-controls { margin: 20px 0; width: 100%; text-align: center; }
        .playback-button { /* Play/Pause button */
            width: 80px; height: 80px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center;
            background: linear-gradient(135deg, var(--primary), var(--secondary)); border: none; cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.4); transition: all 0.3s ease; margin: 0 10px; vertical-align: middle;
            -webkit-tap-highlight-color: transparent; user-select: none;
        }
        .playback-button:hover:not(:disabled) { transform: scale(1.05); box-shadow: 0 0 20px rgba(0, 204, 255, 0.6); }
        .playback-button:active:not(:disabled) { transform: scale(0.95); }
        .playback-button svg { width: 30px; height: 30px; fill: white; }
        .playback-button:focus { outline: none; }
        .playback-button:focus-visible { outline: 2px solid var(--primary); outline-offset: 2px; }

        #song-details img#song-cover {
            max-width: 150px; height: auto; border-radius: 5px; margin-bottom: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3); display: block; margin-left: auto; margin-right: auto;
        }
        #song-details p { margin-bottom: 8px; font-size: 14px; line-height: 1.4; text-align: center; }
        #song-details p strong { color: var(--secondary); }

        /* --- Score Board --- */
        #score-board h3 { font-family: 'Orbitron', sans-serif; margin-bottom: 15px; color: var(--secondary); text-transform: uppercase; letter-spacing: 1px;}
        #score-list { list-style: none; padding: 0; }
        .player-score-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .player-score-item:last-child { border-bottom: none; }
        .player-info { flex-grow: 1; text-align: left; display: flex; align-items: center; margin-right: 10px; overflow: hidden; min-width: 0;}
        .player-name { font-weight: bold; font-size: 1.1em; color: var(--primary); margin-right: 15px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .player-score { /* Score number display */
            font-family: 'Orbitron', sans-serif; font-size: 1.2em; background: rgba(0,0,0,0.2);
            padding: 3px 10px; border-radius: 4px; min-width: 40px; display: inline-block; text-align: center;
        }
        .score-controls { flex-shrink: 0; display: flex; align-items: center; gap: 8px; }
        .score-controls button { /* +/- buttons */
            width: 35px; height: 35px; border-radius: 50%; padding: 0; font-size: 20px;
            line-height: 35px; text-align: center; margin: 0;
        }
        .score-controls .decrement { background: linear-gradient(135deg, #cc0000, var(--danger)); }
        .score-controls .increment { background: linear-gradient(135deg, #009900, var(--success)); }

        /* --- Action Buttons / Game Over --- */
        #action-buttons button { width: 80%; max-width: 300px; margin-top: 10px; } /* Adjust margin */
        #game-over { border: 2px solid var(--success); box-shadow: 0 0 20px rgba(51, 204, 51, 0.5); text-align: center; }
        #game-over h2 { font-family: 'Orbitron', sans-serif; color: var(--success); margin-bottom: 15px; }
        #game-over p { font-size: 1.1em; margin-bottom: 10px; }
        #game-over #reward-message { font-weight: bold; color: var(--text); }
        #game-over #winner-face { /* Winner image */
            width: 100px; height: 100px; border-radius: 50%; margin: 15px auto;
            border: 3px solid var(--success); object-fit: cover; background-color: var(--bg-light);
            /* Default Icon using SVG */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23cccccc"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>');
            background-repeat: no-repeat; background-size: 80%; background-position: center;
            display: block; /* Show by default, hide via JS if no image */
        }

        /* --- Player Face Image Styles --- */
        /* Style for the clickable face area in player setup */
        #player-setup .player-face-control {
            width: 30px; height: 30px; border-radius: 50%; flex-shrink: 0; display: inline-block;
            vertical-align: middle; background-color: var(--bg-light); border: 1px solid var(--secondary);
            background-size: cover; background-position: center; cursor: pointer; position: relative; overflow: hidden;
        }
        #player-setup .player-face-control::after { /* File Upload icon */
            content: '📁'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 16px; color: rgba(255, 255, 255, 0.7); opacity: 0.7; transition: opacity 0.2s ease;
            pointer-events: none;
        }
        #player-setup .player-face-control:not([disabled]):hover::after { opacity: 1; }
        /* Hide icon if image is loaded via background-image */
        #player-setup .player-face-control[style*="background-image"]::after { opacity: 0; }
        #player-setup .player-face-control[disabled] { cursor: not-allowed; opacity: 0.6; }
        #player-setup .player-face-control[disabled]::after { display: none; }

        /* Style for the non-clickable face display in the scoreboard */
        #score-list .player-face-display {
            width: 30px; height: 30px; border-radius: 50%; flex-shrink: 0; display: inline-block;
            vertical-align: middle; background-color: var(--bg-light); border: 1px solid var(--secondary);
            background-size: cover; background-position: center; cursor: default; margin-right: 10px;
            /* Default user icon using SVG */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23cccccc"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>');
            background-repeat: no-repeat; background-size: 80%;
        }

        /* Camera Capture Button (in player setup list) */
        .capture-photo-btn {
            background: none; border: 1px solid var(--secondary); color: var(--secondary);
            border-radius: 50%; width: 30px; height: 30px; font-size: 16px; cursor: pointer;
            padding: 0; margin: 0; line-height: 30px; text-align: center; flex-shrink: 0;
            transition: background-color 0.2s ease, color 0.2s ease;
            display: inline-flex; align-items: center; justify-content: center; /* Center SVG */
        }
        .capture-photo-btn svg { width: 18px; height: 18px; fill: var(--secondary); transition: fill 0.2s ease; }
        .capture-photo-btn:hover:not(:disabled) { background-color: rgba(0, 204, 255, 0.2); color: white; }
        .capture-photo-btn:hover:not(:disabled) svg { fill: white; }
        .capture-photo-btn:disabled { opacity: 0.5; cursor: not-allowed; border-color: #555; }
        .capture-photo-btn:disabled svg { fill: #555; }

        /* --- Photo Capture Modal Styles --- */
        #capture-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(10, 10, 10, 0.9); z-index: 1010; /* Above menu */
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 20px; box-sizing: border-box;
        }
        #capture-modal p { color: var(--secondary); margin-bottom: 15px; font-size: 1.1em; }
        #capture-video {
            max-width: 90%; max-height: 60vh; width: auto; height: auto; border-radius: 8px;
            border: 2px solid var(--secondary); background-color: #000; margin-bottom: 20px;
            transform: scaleX(-1); /* Mirror front camera */
        }
        #capture-canvas { display: none; } /* Hidden canvas for processing */
        #capture-controls { display: flex; gap: 20px; }
        #capture-modal button { /* Style modal buttons */
            padding: 12px 25px; font-size: 15px; margin-top: 0;
        }
        #cancel-capture-btn { background: linear-gradient(135deg, #555, #777); } /* Greyish cancel */
        #cancel-capture-btn:hover { background: linear-gradient(135deg, #666, #888); }

        /* --- Utility --- */
        .hidden { display: none !important; }

    </style>
    <!-- Favicons -->
    <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
    <link rel="manifest" href="./site.webmanifest">
</head>
<body>

    <!-- Hamburger Menu Button -->
    <button id="menu-toggle-btn" aria-label="Toggle Menu" aria-expanded="false" aria-controls="collapsible-menu">
        <span></span>
        <span></span>
        <span></span>
    </button>
    <!-- Collapsible Menu Content -->
    <nav id="collapsible-menu" class="collapsible-menu hidden">
        <ul>
            <li><a href="qr_scanner.html" target="_blank">QR Code Scanner</a></li>
            <li><a href="spelregels.html" target="_blank">Spelregels</a></li>
            <li><a href="scoreboard.html" target="_blank">Open Scoreboard</a></li>
            <li id="menu-quit-item" class="hidden"><button id="menu-quit-btn">Stop Spel</button></li>
            <li id="menu-login-item" class="hidden"><button id="menu-login-btn">Login met Spotify</button></li>
            <li id="menu-logout-item" class="hidden"><button id="menu-logout-btn">Logout</button></li>
        </ul>
    </nav>

    <!-- Main Content Container -->
    <div class="container">
        <h1>HARDSTER</h1>

        <!-- Status Display Area -->
        <div id="status">Verbind met Spotify om door te gaan</div>

        <!-- Hidden file input for image uploads -->
        <input type="file" id="image-upload-input" accept="image/*" class="hidden">

        <!-- Login Area (kept in DOM, hidden by CSS, functionality moved to menu) -->
        <div id="login-area" class="hidden">
            <button id="login-btn" class="full-width">Verbind met Spotify</button>
        </div>

        <!-- Device Selector -->
        <div id="device-selector" class="box hidden">
            <label for="device-list">1. KIES AFSPEEL APPARAAT:</label>
            <select id="device-list"></select>
            <button id="refresh-devices-btn" style="margin-top: 10px;">Ververs Apparaten</button>
        </div>

        <!-- Player Setup -->
        <div id="player-setup" class="box hidden">
            <label for="player-name-input">2. VOEG SPELERS TOE:</label>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <input type="text" id="player-name-input" placeholder="Naam speler">
                <button id="add-player-btn" style="margin-top: 8px; padding: 12px 15px; flex-shrink: 0;">+</button>
            </div>
            <ul id="player-list"></ul>
        </div>

        <!-- Playlist Input & Start Game -->
        <div id="playlist-input-area" class="box hidden">
            <label for="playlist-input">3. SPOTIFY PLAYLIST URL of ID:</label>
            <input type="text" id="playlist-input" placeholder="Plak hier je playlist link of ID">
            <button id="start-game-btn" class="full-width" disabled>Start Spel</button>
        </div>

        <!-- Gameplay Area -->
        <div id="gameplay-area" class="hidden">
            <div id="playback-controls">
                 <button id="play-pause-btn" class="playback-button">
                    <svg id="play-icon" viewBox="0 0 24 24" class="hidden"><path d="M8 5v14l11-7z"></path></svg>
                    <svg id="pause-icon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>
                </button>
            </div>
            <div id="song-details" class="box hidden">
                <img id="song-cover" src="" alt="Album Cover">
                <p><strong>Artiest:</strong> <span id="song-artist"></span></p>
                <p><strong>Titel:</strong> <span id="song-title"></span></p>
                <p><strong>Release:</strong> <span id="song-release"></span></p>
            </div>
            <div id="score-board" class="box hidden">
                <h3>Scores (<span id="points-given-counter">0</span> gegeven)</h3>
                <ul id="score-list"></ul>
            </div>
            <div id="action-buttons" style="margin-top: 20px; width: 100%; text-align: center;">
                 <button id="reveal-btn" class="full-width">Bekijk Nummer</button>
                 <button id="next-btn" class="full-width hidden">Volgende Nummer</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over" class="box hidden">
            <h2>Spel voorbij!</h2>
            <img id="winner-face" src="" alt="Winner Face"> <!-- Removed inline style, handled by CSS/JS -->
            <p><strong id="winner-name"></strong> heeft gewonnen!</p>
            <p id="reward-message"></p>
            <button id="new-game-btn" class="full-width">Nieuw Spel</button>
        </div>

    </div> <!-- Closing .container -->

    <!-- Photo Capture Modal -->
    <div id="capture-modal" class="hidden">
        <p id="capture-status">Camera laden...</p>
        <video id="capture-video" playsinline autoplay muted></video>
        <canvas id="capture-canvas"></canvas> <!-- Hidden canvas -->
        <div id="capture-controls" class="hidden">
            <button id="snap-photo-btn">Neem Foto</button>
            <button id="cancel-capture-btn">Annuleer</button>
        </div>
    </div>

    <!-- Firebase SDKs (v8) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <script>
        // --- Constants ---
        const CLIENT_ID = '412e65076c5b43bdb49fd5ed6a734e17'; // Your Spotify Client ID
        const REDIRECT_URI = window.location.origin + window.location.pathname; // Must match Spotify Dev Dashboard
        const MAX_POINTS_PER_TURN = 3;
        const WIN_SCORE = 40;
        const WINNER_SONG_URI = 'spotify:track:7nYs1auxxJP7jQmJripaBS'; // Example: Queen - We Are The Champions
        const TOKEN_STORAGE_KEY = 'spotifyAccessToken';
        const GAME_STATE_KEY = 'hardsterGameState';
        const FIREBASE_ROOT_PATH = 'hardster/games'; // Firebase RTDB root path for games
        const YOUTUBE_API_KEY = 'AIzaSyCHJZlv_TjxezEGe1fTQ6fmCHjVkwc01y4'; // IMPORTANT: Insecure! Use a backend proxy in production.
        const DB_NAME = 'hardsterFacesDB'; // IndexedDB database name
        const STORE_NAME = 'playerFaces'; // IndexedDB object store name
        const drinkingWords = [
            'beer', 'bier', 'wodka', 'tequila', 'shotje', 'shot',
            'adje', 'atje', 'zuipen', 'alcohol', 'wine', 'whiskey', 'rum', 'gin',
            'drink', 'drunk', 'tipsy', 'borrel', 'jägermeister', 'jagemeister', 'shotjee', 'champagne'
        ];

        // --- DOM Element Cache ---
        const el = {
            status: document.getElementById('status'),
            loginBtn: document.getElementById('login-btn'), // Kept for potential future use, though hidden
            loginArea: document.getElementById('login-area'),
            devSelector: document.getElementById('device-selector'),
            devList: document.getElementById('device-list'),
            refreshDevBtn: document.getElementById('refresh-devices-btn'),
            playerSetup: document.getElementById('player-setup'),
            playerNameInput: document.getElementById('player-name-input'),
            addPlayerBtn: document.getElementById('add-player-btn'),
            playerList: document.getElementById('player-list'),
            playlistInputArea: document.getElementById('playlist-input-area'),
            playlistInput: document.getElementById('playlist-input'),
            startGameBtn: document.getElementById('start-game-btn'),
            gameplayArea: document.getElementById('gameplay-area'),
            playbackControls: document.getElementById('playback-controls'),
            playPauseBtn: document.getElementById('play-pause-btn'),
            playIcon: document.getElementById('play-icon'),
            pauseIcon: document.getElementById('pause-icon'),
            actionButtons: document.getElementById('action-buttons'),
            revealBtn: document.getElementById('reveal-btn'),
            nextBtn: document.getElementById('next-btn'),
            songDetails: document.getElementById('song-details'),
            songCover: document.getElementById('song-cover'),
            songArtist: document.getElementById('song-artist'),
            songTitle: document.getElementById('song-title'),
            songRelease: document.getElementById('song-release'),
            scoreBoard: document.getElementById('score-board'),
            scoreList: document.getElementById('score-list'),
            pointsGivenCounter: document.getElementById('points-given-counter'),
            gameOver: document.getElementById('game-over'),
            winnerName: document.getElementById('winner-name'),
            winnerFace: document.getElementById('winner-face'),
            rewardMessage: document.getElementById('reward-message'),
            newGameBtn: document.getElementById('new-game-btn'),
            menuToggleBtn: document.getElementById('menu-toggle-btn'),
            collapsibleMenu: document.getElementById('collapsible-menu'),
            menuLoginItem: document.getElementById('menu-login-item'),
            menuLogoutItem: document.getElementById('menu-logout-item'),
            menuLoginBtn: document.getElementById('menu-login-btn'),
            menuLogoutBtn: document.getElementById('menu-logout-btn'),
            menuQuitItem: document.getElementById('menu-quit-item'),
            menuQuitBtn: document.getElementById('menu-quit-btn'),
            imageUploadInput: document.getElementById('image-upload-input'),
            captureModal: document.getElementById('capture-modal'),
            captureVideo: document.getElementById('capture-video'),
            captureCanvas: document.getElementById('capture-canvas'),
            captureControls: document.getElementById('capture-controls'),
            snapPhotoBtn: document.getElementById('snap-photo-btn'),
            cancelCaptureBtn: document.getElementById('cancel-capture-btn'),
            captureStatus: document.getElementById('capture-status'),
        };

        // --- State Variables ---
        let accessToken = null;                 // Spotify API access token
        let currentGamePIN = null;              // 4-digit PIN for the current game session
        let currentDeviceId = null;             // Selected Spotify device ID
        let players = [];                       // Array of player objects: { id, name, score, pointsThisTurn, faceDataUrl }
        let playlistTracks = [];                // Array of track objects from Spotify playlist: { id, uri, name }
        let currentTrack = null;                // The currently playing/selected track object
        let currentTrackIndex = -1;             // Index of the current track in the shuffled playlistTracks
        let isPlaying = false;                  // Spotify playback state (true if playing, false if paused)
        let detailsRevealed = false;            // Flag: True if current song details are shown (scoring phase)
        let gameIsOver = false;                 // Flag: True if the game has ended
        let gameInProgress = false;             // Flag: True if a game is actively being played (after start, before game over)
        let currentTargetPlayerId = null;       // Temporarily stores player ID for image upload/capture
        let currentStream = null;               // Media stream for camera capture
        let currentShotMessage = null;          // Stores the generated shot message for the current turn
        let currentVideoIdForScoreboard = null; // YouTube video ID to show on the scoreboard
        let shouldShowVideoOnScoreboard = false;// Flag to control video visibility on the scoreboard

        // Firebase & IndexedDB State
        let firebaseApp;        // Firebase app instance
        let dbRef = null;       // Firebase database reference (dynamic based on PIN)
        let db;                 // IndexedDB database instance

        // --- Firebase Initialization & Setup ---
        /**
         * Initializes the Firebase app if not already initialized.
         */
        function initializeFirebase() {
             if (firebaseApp) return; // Already initialized
             try {
                 const firebaseConfig = {
                     // IMPORTANT: Replace with your actual Firebase config
                     apiKey: "AIzaSyD0nnCDuG_4ymWoWk5AKYaXwnl4nWkVi9s", // USE YOUR CONFIG
                     authDomain: "hardster-7e2c5.firebaseapp.com",
                     databaseURL: "https://hardster-7e2c5-default-rtdb.europe-west1.firebasedatabase.app",
                     projectId: "hardster-7e2c5",
                     storageBucket: "hardster-7e2c5.appspot.com",
                     messagingSenderId: "667886748380",
                     appId: "1:667886748380:web:38b2c60e14158d16ae2a19",
                 };
                 firebaseApp = firebase.initializeApp(firebaseConfig);
                 console.log("Firebase app initialized.");
             } catch (e) {
                 console.error("Firebase initialization failed:", e);
                 showError("Scoreboard verbinding mislukt.");
             }
        }

        /**
         * Sets the Firebase database reference (dbRef) to the specific path for the given PIN.
         * Creates the ref if it doesn't exist or if the PIN changes.
         * @param {string} pin - The 4-digit game PIN.
         * @returns {boolean} True if the reference was set successfully, false otherwise.
         */
        function setFirebaseDbRef(pin) {
            if (!firebaseApp) {
                console.error("Firebase not initialized. Cannot set DB ref.");
                return false;
            }
            if (!pin || typeof pin !== 'string' || !/^\d{4}$/.test(pin)) {
                console.warn("Cannot set Firebase DB ref without a valid 4-digit PIN.", pin);
                dbRef = null; // Ensure ref is null if PIN is invalid
                return false;
            }
            try {
                const newPath = `${FIREBASE_ROOT_PATH}/${pin}`;
                const newRefUrl = firebase.database().ref(newPath).toString();
                // Only create a new ref object if the path changes or ref is null
                if (!dbRef || dbRef.toString() !== newRefUrl) {
                    dbRef = firebase.database().ref(newPath);
                    console.log(`Firebase DB ref set to: ${dbRef.toString()}`);
                }
                return true; // Successfully set or confirmed the ref
            } catch (e) {
                 console.error("Error setting Firebase DB ref:", e);
                 showError("Kon Firebase pad niet instellen.");
                 dbRef = null;
                 return false;
            }
        }

        /**
         * Updates the external scoreboard data in Firebase RTDB under the current game PIN.
         * Sends the current game state (players, scores, game over status, video info, etc.).
         */
        function updateExternalScoreboard() {
            // 1. Check if we have a valid PIN and can set the Firebase reference
            if (!currentGamePIN) {
                 // console.warn("Cannot update external scoreboard: No current game PIN."); // Less verbose
                 return;
            }
            if (!setFirebaseDbRef(currentGamePIN)) { // Ensure dbRef is correctly set
                 console.error("Cannot update external scoreboard: Failed to set Firebase DB ref.");
                 return;
            }

            // 2. Determine winner information if game is over
            const winner = gameIsOver ? players.find(p => p.score >= WIN_SCORE) : null;
            const winnerFaceDataUrl = winner ? (players.find(p => p.id === winner.id)?.faceDataUrl || null) : null;

            // 3. Sort players by score for display on the scoreboard
            const sortedPlayersForExternal = [...players].sort((a, b) => b.score - a.score);

            // 4. Construct the data object to send to Firebase
            const scoreboardData = {
                // Player data (name, score, face URL)
                players: sortedPlayersForExternal.map(p => ({
                    name: p.name,
                    score: p.score,
                    faceDataUrl: p.faceDataUrl || null // Include face data URL (can be null)
                })),
                // Game status
                isGameOver: gameIsOver,
                winnerName: winner ? winner.name : null,
                winnerFaceDataUrl: winnerFaceDataUrl,
                // Current turn state
                shotMessage: gameIsOver ? null : (currentShotMessage || null), // Clear shot msg on game over
                // Scoreboard display state
                currentVideoId: shouldShowVideoOnScoreboard ? (currentVideoIdForScoreboard || null) : null,
                showVideo: shouldShowVideoOnScoreboard,
                isPlaying: isPlaying, // <<< Crucial: Send Spotify playback state for YT sync
                // Timestamp for reference (optional)
                timestamp: firebase.database.ServerValue.TIMESTAMP
            };

            // 5. Send the data to Firebase using set() to overwrite the node
            dbRef.set(scoreboardData)
               .then(() => {
                   // console.log("Firebase updated successfully."); // Optional success log
               })
               .catch(error => console.error("Firebase update failed:", error));
        }

        // --- IndexedDB Helper Functions ---
        /**
         * Initializes the IndexedDB database and object store if they don't exist.
         * @returns {Promise<IDBDatabase>} A promise that resolves with the database instance.
         */
        function initDB() {
             return new Promise((resolve, reject) => {
                if (db) { resolve(db); return; } // Return existing instance if available
                const request = indexedDB.open(DB_NAME, 1); // Version 1
                request.onerror = (event) => { console.error("IndexedDB error:", event.target.error); reject("Error opening IndexedDB."); };
                request.onsuccess = (event) => { db = event.target.result; console.log("IndexedDB initialized successfully."); resolve(db); };
                // onupgradeneeded is triggered only if the version changes or DB doesn't exist
                request.onupgradeneeded = (event) => {
                    const tempDb = event.target.result;
                    if (!tempDb.objectStoreNames.contains(STORE_NAME)) {
                        tempDb.createObjectStore(STORE_NAME); // Create store using player ID as key
                        console.log(`Object store "${STORE_NAME}" created.`);
                    }
                };
            });
        }

        /**
         * Saves an image Blob to IndexedDB using the player ID as the key.
         * Also converts Blob to Data URL and updates the in-memory player state.
         * @param {string} playerId - The ID of the player.
         * @param {Blob} imageBlob - The image data as a Blob.
         * @returns {Promise<void>}
         */
        async function saveImageToDB(playerId, imageBlob) {
            try {
                const currentDb = await initDB(); // Ensure DB is ready
                const transaction = currentDb.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                // Store the Blob directly using the player ID as the key
                const request = store.put(imageBlob, playerId);
                // Wait for the put operation to complete
                await new Promise((resolve, reject) => { request.onsuccess = resolve; request.onerror = (event) => reject(event.target.error); });
                console.log(`Image blob saved to DB for ${playerId} (Size: ${imageBlob.size} bytes)`);

                // Convert Blob to Data URL *only* for immediate in-memory state and Firebase update
                const dataUrl = await blobToDataURL(imageBlob);
                // console.log(`Generated Data URL for ${playerId} (length: ${dataUrl.length})`); // Can be very long

                // Update the in-memory players array
                const playerIndex = players.findIndex(p => p.id === playerId);
                if (playerIndex > -1) {
                    players[playerIndex].faceDataUrl = dataUrl; // Store Data URL in memory
                    // console.log(`Data URL stored in memory for ${players[playerIndex].name}`);
                    saveGameState(); // Save state with updated Data URL
                    updateExternalScoreboard(); // Update external board immediately with new face
                } else {
                    console.warn(`Player ${playerId} not found in memory to store Data URL after saving blob.`);
                }

            } catch (error) {
                console.error("Error saving image blob or generating/storing data URL:", error);
                throw new Error("Could not save image or update state."); // Re-throw for caller
            }
        }

        /**
         * Retrieves an image Blob from IndexedDB by player ID.
         * @param {string} playerId - The ID of the player.
         * @returns {Promise<Blob|null>} A promise resolving with the Blob or null if not found.
         */
        function getImageFromDB(playerId) {
            return new Promise(async (resolve, reject) => {
                try {
                    const currentDb = await initDB();
                    const transaction = currentDb.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get(playerId);
                    request.onsuccess = (event) => resolve(event.target.result || null); // Result is Blob or undefined
                    request.onerror = (event) => { console.error("Error getting image from DB:", event.target.error); reject("Could not retrieve image."); };
                } catch (error) { reject(error); }
            });
        }

        /**
         * Deletes an image from IndexedDB by player ID.
         * @param {string} playerId - The ID of the player.
         * @returns {Promise<void>}
         */
        function deleteImageFromDB(playerId) {
             return new Promise(async (resolve, reject) => {
                try {
                    const currentDb = await initDB();
                    const transaction = currentDb.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.delete(playerId);
                    request.onsuccess = resolve;
                    request.onerror = (event) => { console.error("Error deleting image from DB:", event.target.error); reject("Could not delete image."); };
                } catch (error) { reject(error); }
            });
        }
        // --- END IndexedDB ---

        // --- Utility Helper Functions ---
        /**
         * Displays a message in the status area, optionally with a loading spinner and type styling.
         * @param {string} message - The message text (HTML allowed).
         * @param {boolean} [isLoading=false] - If true, shows a loading spinner.
         * @param {'normal'|'info'|'success'|'error'|'shot'|'pin'} [type='normal'] - Style type for the message.
         */
        function showStatus(message, isLoading = false, type = 'normal') {
             // Remove existing type classes
             el.status.classList.remove('type-info', 'type-success', 'type-error', 'type-shot', 'type-pin');
             // Add new type class if not 'normal'
             if (type !== 'normal') el.status.classList.add(`type-${type}`);
             // Set content with optional spinner
             el.status.innerHTML = isLoading ? `<span class="loading-spinner"></span> ${message}` : message;
        }
        function showPINStatus(pin) { showStatus(`Deel deze PIN voor het scoreboard: <strong>${pin}</strong>`, false, 'pin'); }
        function showError(message) { showStatus(message, false, 'error'); }
        function showSuccess(message) { showStatus(message, false, 'success'); }
        function showInfo(message) { showStatus(message, false, 'info'); }

        /** Shuffles an array in place (Fisher-Yates algorithm). */
        function shuffleArray(array) {
             for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; }
        }

        /** Extracts Spotify Playlist ID from various input formats (URL, URI, ID). */
        function getPlaylistId(input) {
             if (!input || typeof input !== 'string') return null;
             try { const urlMatch = input.match(/open\.spotify\.com\/playlist\/([a-zA-Z0-9]+)/); if (urlMatch && urlMatch[1]) return urlMatch[1]; const uriMatch = input.match(/spotify:playlist:([a-zA-Z0-9]+)/); if (uriMatch && uriMatch[1]) return uriMatch[1]; const idMatch = input.match(/^[a-zA-Z0-9]{22}$/); if (idMatch) return input; } catch (e) { console.error("Error parsing playlist input:", e); } return null;
        }

        /** Updates the visual state of the Play/Pause button. */
        function updatePlayPauseButton() {
             toggleVisibility(el.playIcon, !isPlaying); toggleVisibility(el.pauseIcon, isPlaying); el.playPauseBtn.setAttribute('aria-label', isPlaying ? 'Pause' : 'Play');
        }

        /** Toggles the 'hidden' class on a DOM element. */
        function toggleVisibility(element, show) {
             if (!element) return; element.classList.toggle('hidden', !show);
        }

        /** Generates a random 4-digit PIN as a string. */
        function generatePIN() { return Math.floor(1000 + Math.random() * 9000).toString(); }

        /** Converts a Blob to a Data URL. */
        function blobToDataURL(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(blob);
            });
        }
        // --- END Utilities ---

        // --- YouTube Search Function ---
        /**
         * Searches YouTube for a music video based on artist and title.
         * IMPORTANT: Uses a client-side API key which is insecure for production.
         * @param {string} artist - Track artist.
         * @param {string} title - Track title.
         * @returns {Promise<string|null>} A promise resolving with the YouTube Video ID or null.
         */
        async function searchYouTubeVideo(artist, title) {
            if (!YOUTUBE_API_KEY || YOUTUBE_API_KEY === 'YOUR_YOUTUBE_API_KEY') { // Added check for placeholder
                console.warn("YouTube API Key is missing or is a placeholder. Cannot search for videos.");
                return null;
            }
            // Construct a simple query, prioritizing official music videos
            const query = encodeURIComponent(`${artist} ${title} official music video`);
            const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${query}&type=video&maxResults=1&key=${YOUTUBE_API_KEY}`;
            console.log(`Searching YouTube with query: ${artist} ${title}`);

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: response.statusText } })); // Try to get error details
                    console.error(`YouTube API Error: ${response.status}`, errorData?.error?.message || response.statusText);
                    if (response.status === 403) { showError("YouTube API key error (quota exceeded or invalid?)."); }
                    else { showError(`YouTube search failed (${response.status}).`); }
                    return null;
                }
                const data = await response.json();
                // Check if items exist and the first item has a videoId
                if (data.items && data.items.length > 0 && data.items[0].id?.videoId) {
                    const videoId = data.items[0].id.videoId;
                    console.log(`YouTube video found: ${videoId}`);
                    return videoId;
                } else {
                    console.log("No relevant YouTube video found for this track.");
                    return null;
                }
            } catch (error) {
                console.error("Error fetching YouTube video:", error);
                showError("Network error during YouTube search.");
                return null;
            }
        }
        // --- END YouTube Search ---


        // --- Spotify API Functions ---
        /**
         * Makes a generic call to the Spotify Web API. Handles auth, errors, and JSON parsing.
         * @param {string} endpoint - API endpoint path (e.g., '/me/player/devices').
         * @param {string} [method='GET'] - HTTP method.
         * @param {object|null} [body=null] - Request body for PUT/POST requests.
         * @returns {Promise<{ok: boolean, status: number, data: any|null, error?: Error}>} Result object.
         */
        async function spotifyApiCall(endpoint, method = 'GET', body = null) {
             if (!accessToken) { console.error("Access token is missing for API call."); showError("Niet verbonden met Spotify. Log opnieuw in."); logout(); return { ok: false, status: 401, error: new Error("Access token missing") }; }

             const headers = { 'Authorization': `Bearer ${accessToken}` };
             const options = { method, headers };
             if (body) {
                 options.body = JSON.stringify(body);
                 headers['Content-Type'] = 'application/json'; // Add Content-Type for body
             }

             try {
                 const response = await fetch(`https://api.spotify.com/v1${endpoint}`, options);

                 // Handle 204 No Content success case (common for playback commands)
                 if (response.status === 204) return { ok: true, status: response.status, data: null };

                 // Try to parse JSON, handle potential errors
                 let data = null;
                 const contentType = response.headers.get("content-type");
                 if (contentType && contentType.includes("application/json")) {
                     try { data = await response.json(); }
                     catch (jsonError) {
                         // If parsing failed but response was technically OK (e.g., 200, 202), return success but no data
                         if (response.ok) return { ok: true, status: response.status, data: null };
                         console.error("API response was not valid JSON:", response.status, response.statusText);
                         throw new Error(`API Error: ${response.status} ${response.statusText || 'Invalid JSON Response'}`);
                     }
                 } else if (!response.ok) {
                     // Handle non-JSON error responses
                     console.error("API Error Response (Non-JSON):", response.status, response.statusText);
                     throw new Error(`API Error: ${response.status} ${response.statusText || 'Unknown Error'}`);
                 }

                 // Handle non-OK statuses (4xx, 5xx) even if JSON was parsed
                 if (!response.ok) {
                     console.error("Spotify API Error Response:", data || response.statusText);
                     let errorMessage = data?.error?.message || `API Error: ${response.status}`;
                     const errorReason = data?.error?.reason;

                     // Specific error handling
                     if (response.status === 401) { errorMessage = "Sessie verlopen. Log opnieuw in."; logout(); } // Force logout on 401
                     else if (response.status === 403) errorMessage = "Actie niet toegestaan (Controleer Spotify Premium / Scope).";
                     else if (response.status === 404) errorMessage = "Niet gevonden (Apparaat / Playlist / Nummer?).";
                     else if (response.status === 429) errorMessage = "Te veel requests. Probeer het later opnieuw.";
                     else if (errorReason === 'NO_ACTIVE_DEVICE') errorMessage = "Geen actief apparaat gevonden. Controleer Spotify.";
                     else if (errorReason === 'PREMIUM_REQUIRED') errorMessage = "Spotify Premium is vereist voor deze actie.";

                     throw new Error(errorMessage);
                 }

                 // Success case (200 OK with data, or other 2xx)
                 return { ok: true, status: response.status, data: data };

             } catch (error) {
                 // Catch fetch errors or errors thrown from status checks
                 console.error(`API Call Failed (${method} ${endpoint}):`, error);
                 // Avoid showing redundant error if already handled by logout
                 if (error.message !== "Sessie verlopen. Log opnieuw in.") {
                     showError(error.message || 'Netwerkfout of onbekende API fout.');
                 }
                 return { ok: false, status: error.response?.status || 0, error: error }; // Include status if possible
             }
        }

        /** Fetches available Spotify devices and updates the dropdown. */
        async function getSpotifyDevices() {
             showStatus("Zoeken naar Spotify apparaten...", true);
             el.refreshDevBtn.disabled = true;
             el.devList.innerHTML = ''; // Clear previous options

             const { ok, data, error } = await spotifyApiCall('/me/player/devices');

             el.refreshDevBtn.disabled = false; // Re-enable button

             if (ok && data?.devices?.length > 0) {
                 let activeDeviceFound = false;
                 // Add default placeholder option
                 const defaultOption = document.createElement('option');
                 defaultOption.value = ""; defaultOption.text = "-- Selecteer Apparaat --";
                 defaultOption.disabled = true; // Prevent selection
                 el.devList.appendChild(defaultOption);

                 // Add each device to the list
                 data.devices.forEach(device => {
                     const option = document.createElement('option');
                     option.value = device.id;
                     option.text = `${device.name} (${device.type})${device.is_active ? ' - Actief' : ''}`;
                     // Pre-select if it matches the saved ID or if it's the only active one and no ID was saved
                     if (currentDeviceId === device.id || (!currentDeviceId && device.is_active)) {
                         option.selected = true;
                         if (currentDeviceId !== device.id) { // Update state if auto-selected active device
                            currentDeviceId = device.id;
                            saveGameState(); // Save newly selected device ID
                            updateExternalScoreboard(); // Update FB
                         }
                         activeDeviceFound = true;
                     }
                     el.devList.appendChild(option);
                 });

                 if (activeDeviceFound) {
                     // If a device is selected and we are not in a game, ensure PIN exists and setup is visible
                     if (!gameInProgress) {
                         if (!currentGamePIN) { // Generate PIN only if needed (first time selecting device in session)
                             currentGamePIN = generatePIN();
                             if (!setFirebaseDbRef(currentGamePIN)) {
                                 showError("Kon Firebase niet instellen voor nieuw spel. Probeer opnieuw.");
                                 return; // Stop if Firebase setup fails
                             }
                             saveGameState(); // Save state including the new PIN
                         } else {
                             // Ensure Firebase ref is set if PIN already exists from previous state
                             if (!setFirebaseDbRef(currentGamePIN)) {
                                 showError("Kon Firebase niet herstellen met bestaande PIN.");
                                 return;
                             }
                         }
                         showPINStatus(currentGamePIN); // Show the (new or existing) PIN
                         toggleVisibility(el.playerSetup, true);
                         toggleVisibility(el.playlistInputArea, true);
                     } else {
                         // Game in progress, device found, ensure ref is set
                         if (!setFirebaseDbRef(currentGamePIN)) { showError("Kon Firebase niet herstellen tijdens spel."); /* Consider quitting */ }
                         showInfo("Actief apparaat gevonden."); // No need to show PIN again during game
                     }
                 } else {
                     // Devices found, but none active or matching saved ID
                     defaultOption.selected = true; // Keep placeholder selected
                     currentDeviceId = null;
                     showError("Geen actief apparaat gevonden. Selecteer er een of start Spotify.");
                     toggleVisibility(el.playerSetup, false);
                     toggleVisibility(el.playlistInputArea, false);
                     showStatus("Selecteer een actief apparaat.", false, 'info'); // Clear PIN status
                 }
                 checkCanStartGame(); // Update start button state

             } else {
                 // No devices found at all
                 const option = document.createElement('option');
                 option.disabled = true; option.value = ""; option.text = 'Geen apparaten gevonden';
                 el.devList.appendChild(option);
                 showError(error?.message || "Geen Spotify apparaten gevonden. Open Spotify en start iets.");
                 toggleVisibility(el.playerSetup, false);
                 toggleVisibility(el.playlistInputArea, false);
                 currentDeviceId = null;
                 showStatus("Geen apparaten. Open Spotify en probeer opnieuw.", false, 'error');
                 checkCanStartGame();
             }
        }

        /**
         * Fetches all tracks from a Spotify playlist recursively. Uses cache if playlistId matches input.
         * @param {string} playlistId - The Spotify Playlist ID.
         * @param {boolean} [forceFetch=false] - If true, bypasses cache and fetches fresh.
         * @returns {Promise<Array<{id: string, uri: string, name: string}>>} Array of track objects.
         */
        async function fetchPlaylistTracks(playlistId, forceFetch = false) {
             // Use cached tracks if playlist ID matches current input and not forcing fetch
             if (!forceFetch && playlistTracks.length > 0 && getPlaylistId(el.playlistInput.value) === playlistId) {
                 console.log("Using already loaded playlist tracks.");
                 return playlistTracks;
             }

             let tracks = [];
             let url = `/playlists/${playlistId}/tracks?fields=items(track(id,uri,name)),next&limit=50`; // Start with first 50
             showStatus("Playlist tracks ophalen...", true);

             try {
                 while (url) {
                     const { ok, data, error } = await spotifyApiCall(url);
                     if (!ok) throw error || new Error("Kon tracks niet ophalen");
                     if (data?.items) {
                         // Filter out items without a valid track object
                         const validItems = data.items.filter(item => item.track && item.track.id && item.track.uri);
                         tracks = tracks.concat(validItems.map(item => ({ id: item.track.id, uri: item.track.uri, name: item.track.name })));
                         console.log(`Fetched ${validItems.length} tracks... Total now: ${tracks.length}`);
                     }
                     // Get URL for the next page of results, or null if no more pages
                     url = data.next ? data.next.replace('https://api.spotify.com/v1', '') : null;
                 }

                 if (tracks.length === 0) { showError("Playlist is leeg of bevat geen geldige nummers."); }
                 else { console.log(`Finished fetching playlist. Total tracks: ${tracks.length}`); }
                 playlistTracks = tracks; // Store fetched tracks
                 return tracks;

             } catch (err) {
                 showError(`Fout bij laden playlist: ${err.message}`);
                 playlistTracks = []; // Clear tracks on error
                 return [];
             } finally {
                 // Restore relevant status message (e.g., PIN) after loading, if applicable
                 if (currentGamePIN && !gameInProgress && !gameIsOver && !currentShotMessage && !shouldShowVideoOnScoreboard) {
                     showPINStatus(currentGamePIN);
                 }
                 checkCanStartGame(); // Re-check if game can start
             }
         }

        /**
         * Starts playback of a specific track URI on the selected device.
         * Handles device transfer and playback initiation.
         * @param {string} trackUri - The Spotify URI of the track to play.
         * @returns {Promise<boolean>} True if playback likely started, false otherwise.
         */
        async function playTrack(trackUri) {
             if (gameIsOver) return false;
             if (!currentDeviceId) { showError("Geen afspeelapparaat geselecteerd."); await getSpotifyDevices(); return false; } // Try to find device again

             showStatus("Nummer starten...", true);

             // Attempt to transfer playback / ensure device is active (optional but good practice)
             // We ignore errors here as the play command often works anyway.
             await spotifyApiCall('/me/player', 'PUT', { device_ids: [currentDeviceId], play: false })
                    .catch(e => { console.warn(`Pre-transfer/activate failed (continuing anyway): ${e.message}`); });
             await new Promise(resolve => setTimeout(resolve, 150)); // Short delay after transfer attempt

             // Send the play command with the specific track URI
             const playResult = await spotifyApiCall(`/me/player/play?device_id=${currentDeviceId}`, 'PUT', { uris: [trackUri] });

             if (playResult.ok || playResult.status === 204) { // 200, 202, or 204 indicate success
                 // Update UI if switching to gameplay view
                 if (el.gameplayArea.classList.contains('hidden')) {
                     toggleVisibility(el.devSelector, false); toggleVisibility(el.playerSetup, false);
                     toggleVisibility(el.playlistInputArea, false); toggleVisibility(el.gameplayArea, true);
                 }
                 showInfo("Nummer speelt!");
                 isPlaying = true; // Update state *after* successful command
                 updatePlayPauseButton();
                 return true;
             } else {
                 // Playback failed, handle specific errors
                 let specificError = playResult.error?.message || 'Controleer Spotify & Premium';
                 const errorReason = playResult.error?.reason;
                 if (errorReason === 'NO_ACTIVE_DEVICE' || (playResult.status === 404 && !errorReason)) {
                     specificError = "Apparaat niet actief/gevonden. Selecteer opnieuw of controleer Spotify.";
                     currentDeviceId = null; // Clear invalid device ID
                     toggleVisibility(el.gameplayArea, false); toggleVisibility(el.devSelector, true);
                     await getSpotifyDevices(); // Force re-fetch devices
                 } else if (errorReason === 'PREMIUM_REQUIRED') {
                     specificError = "Spotify Premium is vereist om af te spelen via de API.";
                 }
                 showError(`Afspelen mislukt: ${specificError}`);
                 isPlaying = false; // Ensure state reflects failure
                 updatePlayPauseButton();
                 return false;
             }
        }

        /** Toggles between Play and Pause for the current Spotify playback. */
        async function togglePlayPause() {
             if (gameIsOver || !currentDeviceId || !currentTrack) return; // No action if game over or no track/device

             const endpoint = isPlaying ? 'pause' : 'play';
             const actionText = isPlaying ? 'Pauzeren' : 'Hervatten';
             showStatus(`${actionText}...`, true);
             el.playPauseBtn.disabled = true; // Disable button during API call

             const { ok, status, error } = await spotifyApiCall(`/me/player/${endpoint}?device_id=${currentDeviceId}`, 'PUT');

             el.playPauseBtn.disabled = false; // Re-enable button

             if (ok || status === 204) { // Success
                 isPlaying = !isPlaying; // Update state FIRST
                 showInfo(isPlaying ? "Nummer speelt" : "Gepauzeerd");
                 updatePlayPauseButton();
                 saveGameState(); // Save the new playback state
                 updateExternalScoreboard(); // Send updated state (including isPlaying) to Firebase
             } else {
                 // Handle errors
                 let specificError = error?.message || 'Onbekende fout';
                 const errorReason = error?.reason;
                 if (errorReason === 'NO_ACTIVE_DEVICE' || (status === 404 && !errorReason)) {
                     specificError = "Apparaat niet actief/gevonden. Selecteer opnieuw of controleer Spotify.";
                     currentDeviceId = null;
                     toggleVisibility(el.gameplayArea, false); toggleVisibility(el.devSelector, true);
                     await getSpotifyDevices(); // Force re-fetch devices
                 } else if (errorReason === 'PREMIUM_REQUIRED') {
                     specificError = "Spotify Premium is vereist.";
                 }
                 showError(`Fout bij ${actionText.toLowerCase()}: ${specificError}`);
                 // Don't toggle isPlaying state on error, but update button in case state is now wrong
                 updatePlayPauseButton();
             }
        }

        /** Fetches detailed track information (artist, title, cover, release) from Spotify. */
        async function fetchTrackDetails(trackId) {
             showStatus("Details ophalen...", true);
             const { ok, data, error } = await spotifyApiCall(`/tracks/${trackId}`);

             if (ok && data) {
                 // Find suitable album cover image URL
                 let coverUrl = '';
                 if (data.album.images?.length > 0) {
                     // Prefer image around 300px, fallback to others
                     coverUrl = data.album.images.find(img => img.height === 300)?.url ||
                                data.album.images.find(img => img.height > 150 && img.height < 400)?.url ||
                                data.album.images[0]?.url || // Smallest if others fail
                                data.album.images[data.album.images.length - 1]?.url; // Largest as last resort
                 }
                 return {
                     artist: data.artists.map(a => a.name).join(', '),
                     title: data.name,
                     cover: coverUrl,
                     release: data.album.release_date
                 };
             } else {
                 showError(`Kon details niet laden: ${error?.message || 'Onbekende fout'}`);
                 return null;
             }
        }
        // --- END Spotify API Functions ---

        // --- Player Management & Face Image Handling ---
        /**
         * Loads a player's face image from IndexedDB and displays it using an Object URL.
         * Sets background-image for the provided element. Handles cleanup of old URLs.
         * @param {string} playerId - The ID of the player.
         * @param {HTMLElement} imgElement - The element (span or img) to display the face on.
         */
        async function loadPlayerFace(playerId, imgElement) {
            if (!imgElement) return;

            // 1. Clean up any previous Object URL associated with this element
            if (imgElement.dataset.objectUrl && imgElement.dataset.objectUrl.startsWith('blob:')) {
                URL.revokeObjectURL(imgElement.dataset.objectUrl);
            }
            delete imgElement.dataset.objectUrl; // Remove the data attribute

            // 2. Reset styles (remove existing image, apply default SVG for scoreboard)
            imgElement.style.backgroundImage = '';
            imgElement.style.backgroundSize = 'cover'; // Default for loaded images
            imgElement.style.backgroundRepeat = 'no-repeat';

            // Apply default SVG icon specifically for the scoreboard display as a base
            if (imgElement.classList.contains('player-face-display') || imgElement.id === 'winner-face') {
                imgElement.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23cccccc"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>')`;
                imgElement.style.backgroundSize = '80%'; // Adjust size for SVG icon
            }

            // 3. Try to load the image Blob from IndexedDB
            try {
                const imageBlob = await getImageFromDB(playerId);
                if (imageBlob instanceof Blob) { // Check if we actually got a Blob
                    const imageUrl = URL.createObjectURL(imageBlob);
                    imgElement.style.backgroundImage = `url('${imageUrl}')`; // Display the loaded image
                    imgElement.style.backgroundSize = 'cover'; // Ensure cover for loaded blob image
                    imgElement.dataset.objectUrl = imageUrl; // Store URL for later revocation
                }
                // If no blob, the default SVG (if applicable) remains.
            } catch (error) {
                console.error(`Error loading face for ${playerId}:`, error);
                // Keep default icon on error
            }
        }

        /** Renders the list of players in the setup area. */
        function renderPlayerList() {
             el.playerList.innerHTML = ''; // Clear existing list
             const isGameActive = gameInProgress || gameIsOver; // Disable controls if game running or over

             players.forEach(player => {
                 const li = document.createElement('li');
                 li.dataset.playerId = player.id;

                 // Clickable area for uploading photo (styled span)
                 const faceControl = document.createElement('span');
                 faceControl.className = 'player-face-control';
                 faceControl.dataset.playerId = player.id;
                 faceControl.title = `Upload foto voor ${player.name}`;
                 faceControl.disabled = isGameActive; // Disable during game/game over
                 loadPlayerFace(player.id, faceControl); // Load existing face

                 // Button to trigger camera capture
                 const captureBtn = document.createElement('button');
                 captureBtn.className = 'capture-photo-btn';
                 captureBtn.dataset.playerId = player.id;
                 captureBtn.title = `Maak foto voor ${player.name}`;
                 captureBtn.setAttribute('aria-label', `Maak foto voor ${player.name}`);
                 captureBtn.disabled = isGameActive; // Disable during game/game over
                 captureBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"></path><path d="M12 19c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm0-9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" opacity=".3"></path></svg>`; // Camera icon

                 // Player name display
                 const playerNameSpan = document.createElement('span');
                 playerNameSpan.textContent = player.name;
                 playerNameSpan.className = 'player-list-name';

                 // Remove player button
                 const removeBtn = document.createElement('button');
                 removeBtn.className = 'remove-player-btn';
                 removeBtn.dataset.playerId = player.id;
                 removeBtn.setAttribute('aria-label', `Verwijder ${player.name}`);
                 removeBtn.disabled = isGameActive; // Disable during game/game over
                 removeBtn.innerHTML = '×'; // Use '×' symbol

                 // Append elements to list item
                 li.appendChild(faceControl);
                 li.appendChild(captureBtn);
                 li.appendChild(playerNameSpan);
                 li.appendChild(removeBtn);
                 el.playerList.appendChild(li);
             });
             checkCanStartGame(); // Update start button state based on player count etc.
        }

        /** Adds a new player to the game. */
        function addPlayer() {
             if (gameInProgress || gameIsOver) return; // Don't add players during/after game
             const name = el.playerNameInput.value.trim();
             if (!name) { showError("Voer een naam in."); return; }
             if (players.some(p => p.name.toLowerCase() === name.toLowerCase())) { showError(`Speler "${name}" bestaat al.`); return; }

             const newPlayer = {
                 id: `player_${Date.now()}_${Math.random().toString(16).slice(2)}`, // Unique ID
                 name: name,
                 score: 0,
                 pointsThisTurn: 0,
                 faceDataUrl: null // Initially no face image
             };
             players.push(newPlayer); // Add to state
             renderPlayerList(); // Update UI
             el.playerNameInput.value = ''; // Clear input
             el.playerNameInput.focus();
             showInfo(`Speler "${name}" toegevoegd.`);
             checkCanStartGame();
             saveGameState();
             updateExternalScoreboard(); // Update Firebase with new player list
         }

        /** Removes a player from the game and deletes their image from DB. */
        async function removePlayer(playerId) { // Make async for DB operation
             if (gameInProgress || gameIsOver) return; // Don't remove during/after game
             const playerToRemove = players.find(p => p.id === playerId);
             if (!playerToRemove) return;

             // Clean up Object URL before removing from DOM/state
             const listItem = el.playerList.querySelector(`li[data-player-id="${playerId}"]`);
             const faceControl = listItem?.querySelector('.player-face-control');
             if (faceControl?.dataset.objectUrl?.startsWith('blob:')) {
                 console.log(`Revoking face URL for removed player ${playerId}`);
                 URL.revokeObjectURL(faceControl.dataset.objectUrl);
             }

             // Remove player from state array
             players = players.filter(p => p.id !== playerId);

             // Delete image from IndexedDB (fire and forget, or await if UI depends on it)
             try {
                await deleteImageFromDB(playerId);
                console.log(`Deleted image data for player ${playerId}`);
             } catch(err) {
                console.error(`Failed to delete image data for ${playerId}:`, err);
             }

             renderPlayerList(); // Update UI
             showInfo(`Speler "${playerToRemove.name}" verwijderd.`);
             checkCanStartGame();
             saveGameState();
             updateExternalScoreboard(); // Update Firebase
         }

        /** Handles the file selection for player face image upload. */
        async function handleImageUpload(event) { // Make async for DB saving
            if (!currentTargetPlayerId || gameInProgress || gameIsOver) { // Check game state
                currentTargetPlayerId = null;
                el.imageUploadInput.value = null; // Reset file input
                return;
            }
            const file = event.target.files[0];
            const targetPlayerIdForUpload = currentTargetPlayerId; // Store ID locally
            currentTargetPlayerId = null; // Reset global target

            if (!file || !file.type.startsWith('image/')) {
                if (file) showError("Selecteer een geldig afbeeldingsbestand.");
                el.imageUploadInput.value = null; // Reset file input
                return;
            }

            try {
                showStatus(`Foto voor speler opslaan...`, true);
                await saveImageToDB(targetPlayerIdForUpload, file); // Save Blob to DB, updates memory state
                showSuccess("Foto opgeslagen!");

                // Update the specific face element in the setup list
                const faceElement = document.querySelector(`#player-setup .player-face-control[data-player-id="${targetPlayerIdForUpload}"]`);
                if (faceElement) {
                    await loadPlayerFace(targetPlayerIdForUpload, faceElement); // Reload using ObjectURL from DB
                }
                // Scoreboard face is updated via renderScoreBoard/loadPlayerFace when needed

            } catch (error) {
                showError(`Fout bij opslaan foto: ${error.message || error}`);
            } finally {
                el.imageUploadInput.value = null; // Reset file input regardless of outcome
                // Restore relevant status message if needed
                 if (currentGamePIN && !gameInProgress && !gameIsOver && !currentShotMessage && !shouldShowVideoOnScoreboard) {
                     showPINStatus(currentGamePIN);
                 }
            }
        }
        // --- END Player Management & Face Image ---


        // --- Scoring Logic ---
        /** Renders the scoreboard with current player scores and controls. */
        function renderScoreBoard() {
             el.scoreList.innerHTML = ''; // Clear previous scores
             const totalPointsGivenThisTurn = players.reduce((sum, p) => sum + p.pointsThisTurn, 0);
             el.pointsGivenCounter.textContent = totalPointsGivenThisTurn;

             let sortedPlayers;
             // Sort players based on score *before* this turn's points for stable ranking during scoring phase
             if (detailsRevealed && !gameIsOver) {
                 sortedPlayers = [...players].sort((a, b) => (b.score - b.pointsThisTurn) - (a.score - a.pointsThisTurn));
             } else {
                 // Otherwise (before reveal, game over), sort by current total score
                 sortedPlayers = [...players].sort((a, b) => b.score - a.score);
             }

             const turnActive = detailsRevealed && !gameIsOver; // Scoring buttons active only during scoring phase

             sortedPlayers.forEach(player => {
                 const li = document.createElement('li');
                 li.classList.add('player-score-item');

                 // Determine button states
                 const canIncrementPlayer = player.pointsThisTurn < MAX_POINTS_PER_TURN;
                 const canDecrementPlayer = player.pointsThisTurn > 0; // Can only decrement points added *this turn*

                 // Player Info (Face, Name, Score)
                 const playerInfoDiv = document.createElement('div');
                 playerInfoDiv.className = 'player-info';

                 const faceDisplay = document.createElement('span');
                 faceDisplay.className = 'player-face-display';
                 faceDisplay.dataset.playerId = player.id;
                 loadPlayerFace(player.id, faceDisplay); // Load face image

                 const playerNameSpan = document.createElement('span');
                 playerNameSpan.className = 'player-name';
                 playerNameSpan.textContent = player.name;

                 const playerScoreSpan = document.createElement('span');
                 playerScoreSpan.className = 'player-score';
                 playerScoreSpan.id = `score-${player.id}`;
                 playerScoreSpan.textContent = player.score; // Display total score

                 playerInfoDiv.appendChild(faceDisplay);
                 playerInfoDiv.appendChild(playerNameSpan);
                 playerInfoDiv.appendChild(playerScoreSpan);

                 // Score Controls (+/- Buttons)
                 const scoreControlsDiv = document.createElement('div');
                 scoreControlsDiv.className = 'score-controls';

                 const decrementBtn = document.createElement('button');
                 decrementBtn.className = 'score-btn decrement';
                 decrementBtn.dataset.playerId = player.id;
                 decrementBtn.setAttribute('aria-label', `Punt eraf voor ${player.name}`);
                 decrementBtn.disabled = !canDecrementPlayer || !turnActive; // Enable only if points given this turn & scoring active
                 decrementBtn.textContent = '-';

                 const incrementBtn = document.createElement('button');
                 incrementBtn.className = 'score-btn increment';
                 incrementBtn.dataset.playerId = player.id;
                 incrementBtn.setAttribute('aria-label', `Punt erbij voor ${player.name}`);
                 incrementBtn.disabled = !canIncrementPlayer || !turnActive; // Enable only if max not reached & scoring active
                 incrementBtn.textContent = '+';

                 scoreControlsDiv.appendChild(decrementBtn);
                 scoreControlsDiv.appendChild(incrementBtn);

                 li.appendChild(playerInfoDiv);
                 li.appendChild(scoreControlsDiv);
                 el.scoreList.appendChild(li);
             });
         }

        /**
         * Updates a player's score by a given delta (+1 or -1).
         * Enforces MAX_POINTS_PER_TURN limit and prevents negative scores.
         * @param {string} playerId - The ID of the player to update.
         * @param {number} delta - The change in score (+1 or -1).
         */
        function updateScore(playerId, delta) {
            if (gameIsOver || !detailsRevealed) return; // Scoring only allowed during reveal phase

            const playerIndex = players.findIndex(p => p.id === playerId);
            if (playerIndex === -1) return; // Player not found

            const player = players[playerIndex];
            const originalScore = player.score;
            const originalPointsThisTurn = player.pointsThisTurn;

            if (delta > 0 && player.pointsThisTurn < MAX_POINTS_PER_TURN) {
                // Increment score and points this turn
                player.score++;
                player.pointsThisTurn++;
            } else if (delta < 0 && player.pointsThisTurn > 0) {
                // Decrement score and points this turn (only if points were given this turn)
                player.score--; // Score can potentially go down overall
                player.pointsThisTurn--;
            } else {
                return; // No change possible (max points reached, or trying to remove when none given this turn)
            }

            // If score actually changed, re-render, save, update Firebase, check for win
            if (player.score !== originalScore || player.pointsThisTurn !== originalPointsThisTurn) {
                renderScoreBoard(); // Re-render with updated scores/button states
                saveGameState();
                updateExternalScoreboard(); // Send update with new scores

                // Check for winner immediately after score update
                if (player.score >= WIN_SCORE) {
                    endGame(player); // Trigger game end sequence
                }
            }
        }
        // --- END Scoring Logic ---

        // --- Game State Persistence (LocalStorage) ---
        /** Saves the current game state to LocalStorage. */
        function saveGameState() {
            if (!accessToken) return; // Don't save if not logged in
            if (!currentGamePIN) { console.warn("Attempted to save game state without a PIN. Aborting save."); return; } // Critical: Need PIN

            try {
                 const stateToSave = {
                     gamePIN: currentGamePIN, // Save the PIN
                     players: players.map(p => ({ // Map player data, including face URL
                         id: p.id,
                         name: p.name,
                         score: p.score,
                         pointsThisTurn: p.pointsThisTurn,
                         faceDataUrl: p.faceDataUrl // Store Data URL in LocalStorage state
                     })),
                     currentDeviceId: currentDeviceId,
                     playlistInputValue: el.playlistInput.value, // Save playlist input value
                     // Keep track of current song and phase
                     currentTrackIndex: currentTrackIndex,
                     currentTrack: currentTrack ? { id: currentTrack.id, uri: currentTrack.uri, name: currentTrack.name } : null,
                     detailsRevealed: detailsRevealed,
                     // Game progress flags
                     gameIsOver: gameIsOver,
                     gameInProgress: gameInProgress,
                     // State for external scoreboard sync
                     isPlaying: isPlaying, // Save Spotify playback state
                     currentShotMessage: currentShotMessage,
                     currentVideoIdForScoreboard: currentVideoIdForScoreboard,
                     shouldShowVideoOnScoreboard: shouldShowVideoOnScoreboard
                 };
                 localStorage.setItem(GAME_STATE_KEY, JSON.stringify(stateToSave));
                 // console.log("Game state saved with PIN:", currentGamePIN); // Less verbose
             } catch (e) { console.error("Error saving game state:", e); showError("Fout bij opslaan spelstatus."); }
        }

        /** Loads game state from LocalStorage and restores the game. */
        async function loadGameState() { // Made async for potential async operations inside
            if (!accessToken) return false; // Need token to potentially interact with Spotify API

            const savedStateJSON = localStorage.getItem(GAME_STATE_KEY);
            if (!savedStateJSON) {
                console.log("No saved game state found.");
                // Ensure clean state if nothing loaded
                gameInProgress = false; gameIsOver = false; currentTrack = null; currentTrackIndex = -1;
                detailsRevealed = false; isPlaying = false; currentShotMessage = null;
                currentVideoIdForScoreboard = null; shouldShowVideoOnScoreboard = false;
                // PIN might exist from previous session even without saved game state, don't clear it here.
                return false; // Indicate nothing was loaded
            }

            try {
                console.log("Loading saved game state...");
                const savedState = JSON.parse(savedStateJSON);

                // *** CRITICAL: Load and validate PIN first ***
                currentGamePIN = savedState.gamePIN || null;
                if (!currentGamePIN || typeof currentGamePIN !== 'string' || !/^\d{4}$/.test(currentGamePIN)) {
                     console.error("Loaded game state is missing a valid PIN. Clearing corrupted state.");
                     localStorage.removeItem(GAME_STATE_KEY); // Clear bad state
                     logoutCleanup(); // Trigger full cleanup if state is bad (clears PIN too)
                     updateUIAfterAuthCheck(false); // Force UI to logged-out state
                     return false; // Abort load
                 }
                 console.log("Game state contains valid PIN:", currentGamePIN);

                // PIN is valid, proceed loading other state variables
                players = savedState.players?.map(p => ({
                    ...p,
                    pointsThisTurn: p.pointsThisTurn || 0, // Ensure pointsThisTurn exists
                    faceDataUrl: p.faceDataUrl || null // Ensure faceDataUrl is null if missing
                })) || [];
                currentDeviceId = savedState.currentDeviceId || null;
                el.playlistInput.value = savedState.playlistInputValue || '';
                currentTrackIndex = savedState.currentTrackIndex !== undefined ? savedState.currentTrackIndex : -1;
                currentTrack = savedState.currentTrack || null;
                detailsRevealed = savedState.detailsRevealed || false;
                gameIsOver = savedState.gameIsOver || false;
                gameInProgress = savedState.gameInProgress || false;
                isPlaying = savedState.isPlaying || false; // Load play/pause state
                currentShotMessage = savedState.currentShotMessage || null;
                currentVideoIdForScoreboard = savedState.currentVideoIdForScoreboard || null;
                shouldShowVideoOnScoreboard = savedState.shouldShowVideoOnScoreboard || false;

                // Re-render player list in setup area (disables controls if needed based on loaded gameInProgress/gameIsOver)
                renderPlayerList();

                // Set Firebase reference based on the loaded PIN
                if (!setFirebaseDbRef(currentGamePIN)) {
                     showError("Kon niet verbinden met opgeslagen spel (Firebase pad). Clearing state.");
                     localStorage.removeItem(GAME_STATE_KEY);
                     logoutCleanup(); // Full cleanup needed
                     updateUIAfterAuthCheck(false);
                     return false; // Abort load
                 }

                console.log("Successfully loaded game state variables.");
                // Immediately update the external scoreboard with the loaded state
                updateExternalScoreboard();

                // --- Update UI based on loaded game state ---
                if (gameIsOver) {
                    console.log("Loaded state: Game Over.");
                    // Ensure video is off and playback stopped on game over load
                    shouldShowVideoOnScoreboard = false; currentVideoIdForScoreboard = null; isPlaying = false;
                    const winner = players.find(p => p.id === savedState.winner?.id || p.score >= WIN_SCORE); // Find winner
                    if (winner) {
                        endGameUIUpdate(winner); // Update UI for game over screen
                    } else {
                        console.error("Game over state loaded, but winner could not be determined. Showing generic game over.");
                        toggleVisibility(el.gameplayArea, false); toggleVisibility(el.gameOver, true);
                        el.winnerName.textContent = "Onbekend"; el.rewardMessage.textContent = "";
                        el.winnerFace.style.display = 'none'; el.winnerFace.src = '';
                        // Clean up potential old object URL
                        if (el.winnerFace.dataset.objectUrl) { URL.revokeObjectURL(el.winnerFace.dataset.objectUrl); delete el.winnerFace.dataset.objectUrl; }
                    }
                    showPINStatus(currentGamePIN); // Show PIN even if game over
                    updatePlayPauseButton(); // Reflect isPlaying = false
                    updateExternalScoreboard(); // Send final state update ensuring video off, isPlaying false

                } else if (gameInProgress) {
                    console.log("Loaded state: Game In Progress.");
                    toggleVisibility(el.devSelector, false); toggleVisibility(el.playerSetup, false);
                    toggleVisibility(el.playlistInputArea, false); toggleVisibility(el.gameplayArea, true);
                    toggleVisibility(el.gameOver, false); toggleVisibility(el.menuQuitItem, true);
                    showPINStatus(currentGamePIN); // Show PIN for ongoing game

                    if(currentShotMessage) { showStatus(currentShotMessage, false, 'shot'); } // Show loaded shot message if any

                    // Reload playlist tracks (uses cache if ID matches)
                    const playlistId = getPlaylistId(el.playlistInput.value);
                    if (playlistId) {
                        await fetchPlaylistTracks(playlistId, false); // Load tracks

                        // Check if saved track index is valid within the loaded tracks
                        if (currentTrack && currentTrackIndex >= 0 && currentTrackIndex < playlistTracks.length && playlistTracks[currentTrackIndex]?.id === currentTrack.id) {
                            console.log(`Restored current track: ${currentTrack.name}`);
                            if (detailsRevealed) {
                                // If restoring a "revealed" state...
                                if(currentShotMessage) { showStatus(currentShotMessage, false, 'shot'); }
                                else if (shouldShowVideoOnScoreboard) { showInfo("Video speelt op scoreboard..."); }
                                else { showPINStatus(currentGamePIN); }
                                // Re-fetch details, render board, handle video state (isRestoring = true prevents new video search)
                                await revealSongDetails(true);
                            } else {
                                // Restoring a "not revealed" state (song playing, waiting for reveal)
                                shouldShowVideoOnScoreboard = false; currentVideoIdForScoreboard = null; // Ensure video is off before reveal
                                showPINStatus(currentGamePIN); // Show PIN
                                toggleVisibility(el.songDetails, false); toggleVisibility(el.scoreBoard, false); // Hide details/scores
                                toggleVisibility(el.revealBtn, true); toggleVisibility(el.nextBtn, false); // Show reveal button
                                renderScoreBoard(); // Render board (hidden) to show names/faces initially
                                updateExternalScoreboard(); // Send update ensuring video is off
                            }
                            // Reflect the loaded playback state (could be paused or playing)
                            updatePlayPauseButton();
                            toggleVisibility(el.playbackControls, true); // Ensure controls are visible
                        } else {
                             console.warn("Saved track index invalid or track mismatch. Starting next song.");
                             await playNextRandomSong(); // Play next song, resets turn state (incl. video off)
                        }
                    } else {
                         console.error("Loaded game state had no valid playlist ID. Quitting game.");
                         await quitGame(); // Quit if playlist is unusable
                         return false; // Indicate load failed indirectly
                    }

                } else {
                    // Loaded state is Pre-Game Setup (authenticated, maybe selected device/added players)
                    console.log("Loaded state: Pre-Game Setup.");
                    toggleVisibility(el.gameplayArea, false); toggleVisibility(el.gameOver, false);
                    toggleVisibility(el.menuQuitItem, false);
                    // Ensure video is off and playback state is false for setup phase
                    shouldShowVideoOnScoreboard = false; currentVideoIdForScoreboard = null; isPlaying = false;
                    updatePlayPauseButton();
                    showPINStatus(currentGamePIN); // Show PIN for setup phase

                    // Show setup areas based on whether a device was selected/saved
                    if(currentDeviceId) {
                         toggleVisibility(el.devSelector, true); toggleVisibility(el.playerSetup, true);
                         toggleVisibility(el.playlistInputArea, true);
                    } else {
                        // If no device saved, just show device selector
                         toggleVisibility(el.devSelector, true); toggleVisibility(el.playerSetup, false);
                         toggleVisibility(el.playlistInputArea, false);
                    }
                    updateExternalScoreboard(); // Send update ensuring video off, isPlaying false
                }

                return true; // Indicate state was loaded successfully

            } catch (e) {
                 console.error("Error loading or parsing game state:", e);
                 localStorage.removeItem(GAME_STATE_KEY); // Clear potentially corrupted state
                 showError("Fout bij laden vorige spelstatus. Start opnieuw.");
                 logoutCleanup(); // Full cleanup including PIN
                 updateUIAfterAuthCheck(false);
                 return false; // Indicate load failed
             }
        }
        // --- END Game State Persistence ---

        // --- Game Flow & State Management ---
        /** Checks if the conditions are met to enable the "Start Game" button. */
        function checkCanStartGame() {
             // Conditions: Not already in progress, >0 players, device selected, playlist input not empty, PIN exists
             const canStart = !gameInProgress && !gameIsOver &&
                              players.length > 0 && !!currentDeviceId &&
                              el.playlistInput.value.trim() !== '' && !!currentGamePIN;
             el.startGameBtn.disabled = !canStart;

             // Update status message during setup phase if game not ready
             if (accessToken && !gameInProgress && !gameIsOver) {
                 if (!canStart) { // Only show setup guidance if not ready to start
                     if (!currentDeviceId) { showInfo("Selecteer een afspeelapparaat."); }
                     else if (!currentGamePIN) { showInfo("Selecteer apparaat om PIN te zien/genereren."); } // Should ideally not happen if device selected
                     else if (players.length === 0) { showPINStatus(currentGamePIN); } // Show PIN while adding players
                     else if (!el.playlistInput.value.trim()) { showPINStatus(currentGamePIN); } // Show PIN while entering playlist
                 } else {
                     // Ready to start, ensure PIN is shown if no other message relevant
                      if (!detailsRevealed && !currentShotMessage && !shouldShowVideoOnScoreboard) {
                          showPINStatus(currentGamePIN);
                      }
                 }
             } else if (!accessToken) {
                 showStatus("Verbind met Spotify om door te gaan");
             }
        }

        /** Starts a new game: Fetches playlist, shuffles, resets scores, plays first song. */
        async function startGame() {
             // Pre-checks
             if (!currentGamePIN || !setFirebaseDbRef(currentGamePIN)) { showError("Kan spel niet starten zonder geldige game PIN en Firebase verbinding."); return; }
             const playlistId = getPlaylistId(el.playlistInput.value.trim());
             if (!playlistId) { showError("Ongeldige Spotify Playlist URL of ID."); return; }
             if (players.length === 0) { showError("Voeg minimaal één speler toe."); return; }
             if (!currentDeviceId) { showError("Selecteer een afspeelapparaat."); return; }

             el.startGameBtn.disabled = true; // Disable button immediately
             showStatus("Playlist laden...", true);

             // Fetch playlist tracks (force fetch for new game)
             playlistTracks = await fetchPlaylistTracks(playlistId, true);

             if (playlistTracks?.length > 0) {
                 // Initialize game state
                 shuffleArray(playlistTracks);
                 currentTrackIndex = -1; // Will be incremented by playNextRandomSong
                 gameIsOver = false;
                 gameInProgress = true;
                 detailsRevealed = false;
                 players.forEach(p => { p.score = 0; p.pointsThisTurn = 0; }); // Reset scores
                 currentShotMessage = null;
                 // Reset video state for new game
                 shouldShowVideoOnScoreboard = false; currentVideoIdForScoreboard = null;
                 // isPlaying state will be set by playTrack

                 // Update UI for gameplay
                 toggleVisibility(el.devSelector, false); toggleVisibility(el.playerSetup, false);
                 toggleVisibility(el.playlistInputArea, false); toggleVisibility(el.gameplayArea, true);
                 toggleVisibility(el.gameOver, false); toggleVisibility(el.menuQuitItem, true); // Show Quit button

                 renderPlayerList(); // Disable player add/remove/face buttons
                 renderScoreBoard(); // Render initial scoreboard (scores 0, hidden until reveal)
                 showPINStatus(currentGamePIN); // Ensure PIN is visible at start of game

                 saveGameState(); // Save initial game state (before first song starts)
                 // updateExternalScoreboard() will be called by playNextRandomSong

                 await playNextRandomSong(); // Play the first song

             } else {
                 showError("Kon playlist niet laden of playlist is leeg.");
                 gameInProgress = false; // Reset flag if start failed
                 toggleVisibility(el.menuQuitItem, false);
                 renderPlayerList(); // Re-enable controls in player list
                 if (currentGamePIN) showPINStatus(currentGamePIN); // Keep showing PIN
                 checkCanStartGame(); // Re-enable start button if other conditions met
             }
         }

        /** Resets state variables and UI elements for the start of a new turn. */
        function resetForNewTurn() {
             console.log("Resetting for new turn.");
             detailsRevealed = false;
             players.forEach(p => p.pointsThisTurn = 0); // Reset points *given* this turn
             currentShotMessage = null; // Clear any previous shot message

             // Reset video state for the new turn (hide video on scoreboard)
             shouldShowVideoOnScoreboard = false;
             currentVideoIdForScoreboard = null;
             // isPlaying state carries over until the next song starts/stops

             // Update UI for the "waiting for reveal" phase
             toggleVisibility(el.songDetails, false); // Hide previous song details
             toggleVisibility(el.scoreBoard, false); // Hide scoreboard until reveal
             toggleVisibility(el.revealBtn, true);   // Show Reveal button
             el.revealBtn.disabled = false;          // Ensure Reveal button is enabled
             toggleVisibility(el.nextBtn, false);    // Hide Next button
             toggleVisibility(el.playbackControls, true); // Ensure playback controls are visible

             // Render the scoreboard structure (players/faces) but keep it hidden
             renderScoreBoard();

             // Update Firebase BEFORE starting next song to hide video and clear shot message
             // The 'isPlaying' state sent here reflects the state *before* the next song starts playing.
             updateExternalScoreboard();

             // Show PIN status if no other message is relevant
             if (currentGamePIN) showPINStatus(currentGamePIN);
        }

        /** Plays the next random (or sequential after shuffle) song from the playlist. */
        async function playNextRandomSong() {
             if (gameIsOver) return;

             // 1. Reset state and UI for the new turn
             resetForNewTurn(); // This also updates Firebase to hide video/clear message

             // 2. Check if playlist is loaded
             if (!playlistTracks || playlistTracks.length === 0) {
                 showError("Geen nummers geladen. Controleer playlist.");
                 await quitGame(); // Quit if playlist unusable
                 return;
             }

             // 3. Select next track index, reshuffle if needed
             currentTrackIndex++;
             if (currentTrackIndex >= playlistTracks.length) {
                 shuffleArray(playlistTracks);
                 currentTrackIndex = 0;
                 showInfo("Playlist opnieuw geschud.");
                 // Basic attempt to avoid immediate repeat after shuffle
                 if (playlistTracks.length > 1 && currentTrack && playlistTracks[0].uri === currentTrack.uri) {
                     currentTrackIndex = 1; // Play the second song instead if possible
                 }
             }

             // Safety check for index after potential shuffle/adjustment
             if (currentTrackIndex >= playlistTracks.length) {
                 showError("Fout bij selecteren volgend nummer na schudden.");
                 await quitGame();
                 return;
             }

             // 4. Set the current track
             currentTrack = playlistTracks[currentTrackIndex];
             console.log(`Playing next: #${currentTrackIndex + 1} - ${currentTrack.uri} (${currentTrack.name})`);

             // 5. Start playback
             // Scoreboard remains hidden until reveal
             toggleVisibility(el.scoreBoard, false);
             const started = await playTrack(currentTrack.uri); // This updates `isPlaying` state

             // 6. Handle playback start result
             if (started) {
                 saveGameState(); // Save state with new track index, video off, isPlaying=true
                 updateExternalScoreboard(); // Send update reflecting new song started (video off, isPlaying=true)
             } else {
                 // Playback failed
                 showError("Kon volgend nummer niet starten. Controleer apparaat/verbinding.");
                 isPlaying = false; // Ensure state reflects failure
                 updatePlayPauseButton();
                 // Don't advance game state further, allow user to retry or quit
                 // gameInProgress remains true
                 currentTrack = null; // Clear failed track
                 currentTrackIndex--; // Revert index to allow retry of same effective song next time? Or just quit? Let's revert.
                 saveGameState();
                 updateExternalScoreboard(); // Send update (isPlaying=false)
                 if (currentGamePIN) showPINStatus(currentGamePIN); // Show PIN again
                 // Don't automatically call checkCanStartGame here, as game is technically stuck
             }
        }

        /** Reveals the current song's details, checks for shot messages, and potentially starts video. */
        async function revealSongDetails(isRestoring = false) {
             // Prevent multiple reveals or revealing when not appropriate
             if (gameIsOver || !currentTrack || (detailsRevealed && !isRestoring)) return;

             el.revealBtn.disabled = true; // Disable button during processing
             if (!isRestoring) showStatus("Details ophalen...", true); // Show loading only on first reveal

             // Fetch song details from Spotify API
             const details = await fetchTrackDetails(currentTrack.id);
             if (!details) {
                 if (!isRestoring) showError("Kon details niet laden. Probeer opnieuw."); // Show error only on first reveal
                 el.revealBtn.disabled = false; // Allow retry
                 return; // Stop if details failed
             }

             // Update song details display
             el.songArtist.textContent = details.artist;
             el.songTitle.textContent = details.title;
             el.songCover.src = details.cover || ''; // Use fetched cover URL or empty string
             el.songCover.style.display = details.cover ? 'block' : 'none'; // Hide img element if no cover
             el.songRelease.textContent = details.release;

             // --- State Update & UI Toggle for Scoring Phase ---
             detailsRevealed = true; // Enter scoring phase
             toggleVisibility(el.songDetails, true); // Show song details box
             toggleVisibility(el.scoreBoard, true);  // SHOW scoreboard now
             renderScoreBoard(); // Render scoreboard with stable player order and active controls
             toggleVisibility(el.revealBtn, false); // Hide Reveal button
             toggleVisibility(el.nextBtn, true);    // Show Next button

             // Reset shot message before check
             currentShotMessage = null;

             // --- Handle Video Search & Display (only if not just restoring state) ---
             if (!isRestoring) {
                let foundVideoId = await searchYouTubeVideo(details.artist, details.title);
                currentVideoIdForScoreboard = foundVideoId; // Store found ID (or null)
                shouldShowVideoOnScoreboard = !!foundVideoId; // Set flag based on search result
                console.log(`Video Search Result: ID=${currentVideoIdForScoreboard}, Show=${shouldShowVideoOnScoreboard}`);
             } else {
                 // If restoring, video ID and show flag were already loaded by loadGameState()
                 console.log(`Restoring revealed state. Video state: ID=${currentVideoIdForScoreboard}, Show=${shouldShowVideoOnScoreboard}`);
             }

             // --- Handle Shot Message & Status Update ---
             // Check for drinking words only if not restoring (avoid duplicate messages)
             if (!isRestoring) {
                 const lowerTitle = details.title.toLowerCase();
                 const triggerWord = drinkingWords.find(word => lowerTitle.includes(word));
                 if (triggerWord && players.length > 0) {
                     // Assign shot randomly
                     const unluckyPlayer = players[Math.floor(Math.random() * players.length)];
                     currentShotMessage = `🍻 ${unluckyPlayer.name} moet een shotje nemen! ('${triggerWord}')`;
                     showStatus(currentShotMessage, false, 'shot'); // Display shot message
                 }
             }

             // Update status based on shot message / video state
             if (currentShotMessage) {
                 showStatus(currentShotMessage, false, 'shot'); // Ensure shot message shown (even if restoring)
             } else if (shouldShowVideoOnScoreboard) {
                 showInfo("Video speelt op scoreboard..."); // Indicate video is playing
             } else {
                 showInfo("Geef punten!"); // Default message for scoring phase
             }

             // --- Final State Updates ---
             // Update Firebase and save state AFTER determining messages/video state
             updateExternalScoreboard(); // Sends revealed state, video state, isPlaying state
             saveGameState(); // Save state including revealed flag, video state, isPlaying

             // Note: If restoring, Firebase/LocalStorage are already up-to-date from loadGameState
         }
        // --- END Game Flow & State ---


        // --- End Game, Quit Game, New Game Logic ---
        /** Updates the UI specifically for the game over state. */
        function endGameUIUpdate(winner) {
             if (!winner) return; // Safety check

             // Calculate reward based on player count (matches scoreboard logic)
             const shots = (players.length >= 5 ? 2 : 1);
             el.winnerName.textContent = winner.name;
             el.rewardMessage.textContent = `${winner.name} mag ${shots} shot${shots > 1 ? 's' : ''} uitdelen!`;

             // Load and display winner's face image
             el.winnerFace.src = ''; // Clear previous src
             el.winnerFace.style.backgroundImage = ''; // Clear potential default icon BG
             el.winnerFace.style.display = 'none'; // Hide initially
             // Clean up previous object URL if any
             if (el.winnerFace.dataset.objectUrl?.startsWith('blob:')) {
                 URL.revokeObjectURL(el.winnerFace.dataset.objectUrl);
                 delete el.winnerFace.dataset.objectUrl;
             }
             // Attempt to load from IndexedDB
             getImageFromDB(winner.id)
                 .then(imageBlob => {
                     if (imageBlob instanceof Blob) {
                         const imageUrl = URL.createObjectURL(imageBlob);
                         el.winnerFace.src = imageUrl; // Use src for <img>
                         el.winnerFace.style.backgroundImage = ''; // Ensure no default BG interferes
                         el.winnerFace.style.display = 'block';
                         el.winnerFace.dataset.objectUrl = imageUrl; // Store for cleanup
                         el.winnerFace.onerror = () => { // Fallback if ObjectURL somehow fails on src
                             console.warn("Winner face Object URL failed to load in src, using default icon.");
                             el.winnerFace.src = '';
                             el.winnerFace.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23cccccc"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>')`;
                             el.winnerFace.style.backgroundSize = '80%';
                             el.winnerFace.style.display = 'block'; // Still show the element with BG
                         };
                     } else {
                         // No image blob found, use default SVG background
                         el.winnerFace.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23cccccc"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>')`;
                         el.winnerFace.style.backgroundSize = '80%';
                         el.winnerFace.style.display = 'block'; // Show element with default BG
                     }
                 })
                 .catch(err => {
                     console.error("Failed to load winner face:", err);
                     // Use default SVG background on error loading from DB
                     el.winnerFace.style.backgroundImage = `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23cccccc"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>')`;
                     el.winnerFace.style.backgroundSize = '80%';
                     el.winnerFace.style.display = 'block'; // Show element with default BG
                 });


             // Toggle UI visibility for game over screen
             toggleVisibility(el.devSelector, false); toggleVisibility(el.playerSetup, false);
             toggleVisibility(el.playlistInputArea, false); toggleVisibility(el.gameplayArea, false);
             toggleVisibility(el.gameOver, true); // Show game over box
             toggleVisibility(el.menuQuitItem, false); // Hide Quit Game button

             renderScoreBoard(); // Render final scores (though scoreboard itself is hidden)
             if (currentGamePIN) showPINStatus(currentGamePIN); // Still show PIN
        }

        /** Ends the current game, displays the winner, and stops playback. */
        async function endGame(winner) {
             if (gameIsOver || !winner) return; // Prevent multiple calls or calls without winner

             gameIsOver = true; gameInProgress = false; detailsRevealed = false; // Update game state flags
             // Reset video state on game end
             shouldShowVideoOnScoreboard = false; currentVideoIdForScoreboard = null;

             console.log(`Game Over! Winner: ${winner.name}`);

             // Attempt to stop Spotify playback
             let pauseAttempted = false;
             if (isPlaying && accessToken && currentDeviceId) {
                 try {
                     await spotifyApiCall('/me/player/pause', 'PUT');
                     isPlaying = false; // Update state AFTER successful pause
                     pauseAttempted = true;
                     console.log("Paused Spotify playback on game end.");
                } catch(e){ console.warn("Failed to pause Spotify on game end:", e); /* isPlaying might remain true if pause failed, but we set it false below */ }
             }
             // Ensure isPlaying is false regardless of pause success
             isPlaying = false;
             updatePlayPauseButton(); // Reflect paused state visually

             // Optionally play a winner announcement song (fire and forget)
             if (accessToken && currentDeviceId && WINNER_SONG_URI) {
                 console.log("Attempting to play winner song...");
                 spotifyApiCall(`/me/player/play?device_id=${currentDeviceId}`, 'PUT', { uris: [WINNER_SONG_URI] })
                     .catch(e => console.warn("Failed to play winner song:", e));
             }

             // Update the UI to show the winner screen
             endGameUIUpdate(winner);

             // Update Firebase with the final game over state
             updateExternalScoreboard(); // Sends isGameOver: true, video off, isPlaying: false, winner info

             // Save the final game over state to LocalStorage
             saveGameState();
         }

        /** Quits the current game in progress, resets state, removes Firebase data, returns to setup. */
        async function quitGame() {
             console.log("Quitting game / Resetting to setup...");
             closeCaptureModal(); // Ensure camera modal is closed

             // 1. Stop Spotify Playback
             let wasPlaying = isPlaying;
             isPlaying = false; // Assume stopped
             updatePlayPauseButton();
             if (wasPlaying && accessToken && currentDeviceId) {
                 try { await spotifyApiCall('/me/player/pause', 'PUT'); }
                 catch(e){ console.warn("Failed to pause Spotify on quit game:", e); }
             }

             // 2. Update Firebase BEFORE removing data (to hide video etc. on scoreboard)
             shouldShowVideoOnScoreboard = false; currentVideoIdForScoreboard = null;
             updateExternalScoreboard(); // Sends isPlaying: false, showVideo: false, etc.

             // 3. Remove game data from Firebase *under the current PIN*
             if (dbRef) { // Use existing ref if available
                 await dbRef.remove()
                    .then(() => console.log(`Removed game data from Firebase at ${dbRef.toString()} (keeping PIN ${currentGamePIN})`))
                    .catch(e => console.error(`Failed to remove game data from Firebase ref: ${e.message}`));
             } else if (currentGamePIN) { // Fallback: build ref from PIN and remove
                 await firebase.database().ref(`${FIREBASE_ROOT_PATH}/${currentGamePIN}`).remove()
                    .then(() => console.log(`Removed game data from Firebase for PIN ${currentGamePIN} (without active ref)`))
                    .catch(e => console.error(`Failed to remove game data for PIN ${currentGamePIN}: ${e.message}`));
             }

             // 4. Reset Local Game State Variables (KEEP players array and PIN, reset scores)
             playlistTracks = []; currentTrack = null; currentTrackIndex = -1;
             detailsRevealed = false; gameIsOver = false; gameInProgress = false;
             currentShotMessage = null;
             // Video state already reset above

             // Clear scores but keep players and their faces
             players.forEach(p => { p.score = 0; p.pointsThisTurn = 0; });

             // 5. Clean up Object URLs from player list display elements
             document.querySelectorAll('#player-list .player-face-control[data-object-url]').forEach(el => {
                 if (el.dataset.objectUrl.startsWith('blob:')) { try { URL.revokeObjectURL(el.dataset.objectUrl); } catch(e) { /* ignore */ } }
                 delete el.dataset.objectUrl; el.style.backgroundImage = ''; // Reset style
             });

             // 6. Save the reset state (scores 0, game not in progress, keeps PIN)
             saveGameState();
             console.log("Game state reset (scores cleared, keeping PIN) and saved.");

             // 7. Reset UI to Setup Phase
             toggleVisibility(el.gameplayArea, false); toggleVisibility(el.gameOver, false);
             toggleVisibility(el.songDetails, false); toggleVisibility(el.scoreBoard, false);
             toggleVisibility(el.menuQuitItem, false); // Hide Quit button
             toggleVisibility(el.devSelector, true); // Show device selector again

             // Show player/playlist setup only if device is still selected and PIN exists
             const showSetup = !!currentDeviceId && !!currentGamePIN;
             toggleVisibility(el.playerSetup, showSetup);
             toggleVisibility(el.playlistInputArea, showSetup);

             renderPlayerList(); // Re-render player list (enables controls, shows 0 scores implicitly)
             el.playlistInput.value = ''; // Clear playlist input

             // 8. Refresh devices and update status message
             if (accessToken) {
                 showInfo("Spel gestopt. Stel opnieuw in.");
                 await getSpotifyDevices(); // Re-fetch devices, will reuse existing PIN & update status/UI
             } else {
                 showStatus("Verbind met Spotify om door te gaan"); // Should not happen if game was in progress
             }
             checkCanStartGame(); // Update start button state

             // Close menu if open
             if (el.collapsibleMenu && !el.collapsibleMenu.classList.contains('hidden')) { toggleMenu(); }
        }

        /** Sets up for a new game starting from the game over screen. */
         async function setupNewGame() {
            console.log("Setting up for a new game (from game over)...");
            closeCaptureModal(); // Close camera if open

            // 1. Clean up winner face Object URL
            if (el.winnerFace.dataset.objectUrl?.startsWith('blob:')) {
                try { URL.revokeObjectURL(el.winnerFace.dataset.objectUrl); } catch(e) { /* ignore */ }
                delete el.winnerFace.dataset.objectUrl;
            }
            el.winnerFace.src = ''; el.winnerFace.style.display = 'none'; // Hide winner face

             // 2. Update Firebase BEFORE removing data (ensure scoreboard clears winner, video)
             isPlaying = false; // Ensure playback state is false
             shouldShowVideoOnScoreboard = false; currentVideoIdForScoreboard = null;
             gameIsOver = false; // Mark game as not over for the update
             // Note: We don't clear players yet for this update, just winner/gameover state
             updateExternalScoreboard();

             // 3. Remove old game data from Firebase (using current PIN)
             if (dbRef && currentGamePIN && dbRef.toString().includes(currentGamePIN)) {
                 await dbRef.remove()
                    .then(() => console.log(`Removed previous game data from Firebase at ${dbRef.toString()} (keeping PIN ${currentGamePIN})`))
                    .catch(e => console.error(`Failed to remove previous game data: ${e.message}`));
             } else if (currentGamePIN) {
                 await firebase.database().ref(`${FIREBASE_ROOT_PATH}/${currentGamePIN}`).remove()
                    .then(() => console.log(`Removed previous game data for PIN ${currentGamePIN} (without active ref)`))
                    .catch(e => console.error(`Failed to remove previous game data for PIN ${currentGamePIN}: ${e.message}`));
             }

            // 4. Reset Local Game State Variables (KEEP players array and PIN, reset scores)
            playlistTracks = []; currentTrack = null; currentTrackIndex = -1;
            detailsRevealed = false; /* gameIsOver already false */ gameInProgress = false;
            currentShotMessage = null;
            // Video state already reset above

            // Clear scores but keep players and their faces
            players.forEach(p => { p.score = 0; p.pointsThisTurn = 0; });

            // 5. Save the reset state (scores 0, game not over, keeps PIN)
             saveGameState();
             console.log("Game state reset for new game (scores cleared, keeping PIN) and saved.");

            // 6. Reset UI to Setup Phase
            toggleVisibility(el.gameplayArea, false); toggleVisibility(el.gameOver, false);
            toggleVisibility(el.songDetails, false); toggleVisibility(el.scoreBoard, false);
            toggleVisibility(el.menuQuitItem, false);
            toggleVisibility(el.devSelector, true); // Show device selector

            const showSetup = !!currentDeviceId && !!currentGamePIN;
            toggleVisibility(el.playerSetup, showSetup);
            toggleVisibility(el.playlistInputArea, showSetup);

            renderPlayerList(); // Re-render player list (enables controls)
            el.playlistInput.value = ''; // Clear playlist input

            // 7. Refresh devices and update status
            if (accessToken) {
                 showInfo("Klaar voor nieuw spel. Selecteer apparaat/playlist.");
                 await getSpotifyDevices(); // Re-fetch devices, reuse PIN, update status
            } else {
                 showStatus("Verbind met Spotify om door te gaan");
            }
            checkCanStartGame(); // Update start button
        }
        // --- END End Game, Quit Game, New Game ---


        // --- Authentication and Menu Functions ---
        /** Validates a Spotify token by making a '/me' call. Updates state and storage. */
        async function validateAndSetToken(token) {
             accessToken = token; // Temporarily set token for the API call
             console.log("Validating stored/new token...");
             const { ok, error, status } = await spotifyApiCall('/me'); // Simple call to check validity

             if (ok) {
                 console.log("Token is valid.");
                 localStorage.setItem(TOKEN_STORAGE_KEY, token); // Store the valid token
                 return true;
             } else {
                 console.log("Token validation failed or expired.", status, error?.message);
                 accessToken = null; // Clear invalid token from state
                 localStorage.removeItem(TOKEN_STORAGE_KEY); // Remove invalid token from storage
                 // Avoid showing redundant error if it's just an expired session handled by logout()
                 if (status !== 401 && error && error.message !== "Sessie verlopen. Log opnieuw in.") {
                     showError("Kon Spotify verbinding niet valideren.");
                 }
                 return false;
             }
        }

        /** Checks for existing auth token (URL hash or LocalStorage), validates it, and updates UI. */
        async function checkAuth() {
             let authenticated = false;
             try {
                 // Check for token in URL hash (from Spotify redirect)
                 const hashParams = new URLSearchParams(window.location.hash.substring(1));
                 const tokenFromUrl = hashParams.get('access_token');
                 const errorFromUrl = hashParams.get('error');

                 // Clean the hash from the URL immediately
                 history.replaceState(null, null, window.location.pathname + window.location.search);

                 if (errorFromUrl) {
                     showError(`Spotify Login Fout: ${errorFromUrl}`);
                     logoutCleanup(); // Clean up if login failed
                     authenticated = false;
                 } else if (tokenFromUrl) {
                     // Found token in URL, validate and store it
                     console.log("Token found in URL hash.");
                     authenticated = await validateAndSetToken(tokenFromUrl);
                     if (!authenticated) logoutCleanup(); // Clean up if validation fails
                 } else {
                     // No token in URL, check LocalStorage
                     const tokenFromStorage = localStorage.getItem(TOKEN_STORAGE_KEY);
                     if (tokenFromStorage) {
                         console.log("Token found in localStorage.");
                         authenticated = await validateAndSetToken(tokenFromStorage);
                         if (!authenticated) logoutCleanup(); // Clean up if stored token is invalid/expired
                     } else {
                         console.log("No token found in URL or localStorage.");
                         logoutCleanup(); // Ensure clean state if no token found
                         authenticated = false;
                     }
                 }
             } catch (e) {
                 console.error("Error during auth check:", e);
                 logoutCleanup(); // Clean up on any error during auth check
                 authenticated = false;
                 showError("Fout bij authenticatie controle.");
             }

             // Update menu items visibility based on auth status
             updateUIAfterAuthCheck(authenticated);

             if (authenticated) {
                 initializeFirebase(); // Init Firebase now that we are logged in

                 // Attempt to load game state (loads PIN, game progress, etc.)
                 const loadedFromState = await loadGameState();

                 // --- Logic after loading state (or not) ---
                 if (loadedFromState) {
                     // State successfully loaded, UI updated within loadGameState
                     console.log("Auth successful, game state loaded/resumed with PIN:", currentGamePIN);
                 } else if (currentGamePIN) {
                     // No specific game state loaded, but a PIN exists from a previous session (or load failure)
                     console.log("Auth successful, no specific game state loaded, reusing existing PIN:", currentGamePIN);
                     // Ensure Firebase ref is set for this PIN
                     if (!setFirebaseDbRef(currentGamePIN)) {
                         showError("Kon Firebase niet instellen met bestaande PIN. Clearing PIN.");
                         logoutCleanup(); updateUIAfterAuthCheck(false); return;
                     }
                     // Ensure video state is reset if reusing PIN without loaded game state
                     shouldShowVideoOnScoreboard = false; currentVideoIdForScoreboard = null; isPlaying = false;
                     updateExternalScoreboard(); // Update FB with reset video state
                     // Show setup UI if device was potentially selected before
                     if(currentDeviceId) {
                         toggleVisibility(el.devSelector, true); toggleVisibility(el.playerSetup, true);
                         toggleVisibility(el.playlistInputArea, true); showPINStatus(currentGamePIN);
                     } else {
                         toggleVisibility(el.devSelector, true); toggleVisibility(el.playerSetup, false);
                         toggleVisibility(el.playlistInputArea, false); showInfo("Selecteer afspeelapparaat.");
                     }
                 } else {
                     // Auth successful, no game state, no existing PIN - fresh session
                     console.log("Auth successful, no game state or PIN found. Ready for setup.");
                     showInfo("Selecteer afspeelapparaat om te beginnen.");
                 }

                 // Always fetch devices after successful auth (updates list, potentially generates PIN if needed)
                 await getSpotifyDevices();

                 // Final UI adjustments based on current state
                 if (!currentDeviceId && authenticated) { // If still no device after getSpotifyDevices
                    toggleVisibility(el.devSelector, true); toggleVisibility(el.playerSetup, false); toggleVisibility(el.playlistInputArea, false);
                 }
                 checkCanStartGame(); // Update start button state
                 toggleVisibility(el.menuQuitItem, gameInProgress && !gameIsOver); // Show/hide Quit button
                 updatePlayPauseButton(); // Ensure play/pause button reflects current (potentially loaded) state

             } else {
                 // Not authenticated
                 showStatus("Verbind met Spotify om door te gaan");
             }
             return authenticated;
        }

        /** Initiates the Spotify login flow. */
        function login() {
            saveGameState(); // Save current state before redirecting
            const scopes = 'user-read-private user-read-email streaming user-modify-playback-state user-read-playback-state';
            const authUrl = 'https://accounts.spotify.com/authorize?' + new URLSearchParams({
                response_type: 'token',
                client_id: CLIENT_ID,
                scope: scopes,
                redirect_uri: REDIRECT_URI,
                show_dialog: 'true' // Force user to re-approve permissions
            }).toString();
            window.location.href = authUrl; // Redirect to Spotify
        }

        /** Cleans up all sensitive/session-specific state. Called on logout or critical errors. */
        function logoutCleanup() {
            console.log("Performing logout cleanup...");
            accessToken = null;
            currentGamePIN = null; // <<< Clear the PIN on full logout
            dbRef = null; // Clear Firebase reference
            closeCaptureModal(); // Close camera

            // Clear storage
            localStorage.removeItem(TOKEN_STORAGE_KEY);
            localStorage.removeItem(GAME_STATE_KEY);

            // Revoke all existing Object URLs to prevent memory leaks
            document.querySelectorAll('[data-object-url]').forEach(element => {
                if (element.dataset.objectUrl?.startsWith('blob:')) {
                    try { URL.revokeObjectURL(element.dataset.objectUrl); } catch(e) { console.warn("Error revoking Object URL on logout:", e); }
                }
                delete element.dataset.objectUrl;
                // Reset display element style/src
                if(element.tagName === 'IMG') element.src = '';
                else element.style.backgroundImage = '';
            });

            // Reset all game state variables
            players = []; playlistTracks = []; currentTrack = null; currentTrackIndex = -1;
            isPlaying = false; detailsRevealed = false; gameIsOver = false; gameInProgress = false;
            currentDeviceId = null; currentShotMessage = null;
            shouldShowVideoOnScoreboard = false; currentVideoIdForScoreboard = null;

            console.log("Cleaned up tokens, PIN, game state, Object URLs, and variables.");
        }

        /** Updates the main UI elements based on authentication status. */
        function updateUIAfterAuthCheck(isAuthenticated) {
             // Toggle menu items
             toggleVisibility(el.menuLoginItem, !isAuthenticated);
             toggleVisibility(el.menuLogoutItem, isAuthenticated);

             // Hide setup/gameplay areas if not authenticated
             if (!isAuthenticated) {
                 toggleVisibility(el.devSelector, false);
                 toggleVisibility(el.playerSetup, false);
                 toggleVisibility(el.playlistInputArea, false);
                 toggleVisibility(el.gameplayArea, false);
                 toggleVisibility(el.gameOver, false);
                 toggleVisibility(el.menuQuitItem, false); // Hide quit if not logged in
                 // Clear dynamic content areas
                 el.devList.innerHTML = '';
                 el.playerList.innerHTML = '';
                 el.scoreList.innerHTML = '';
                 el.playlistInput.value = '';
                 showStatus("Verbind met Spotify om door te gaan"); // Reset status message
             }
             // If authenticated, other UI elements are handled by loadGameState/getSpotifyDevices
        }

        /** Handles user logout action. */
        async function logout() {
            console.log("User logging out...");
            let wasPlaying = isPlaying; // Store state before trying to pause
            isPlaying = false; // Assume stopped
            updatePlayPauseButton();

            // Attempt to pause Spotify playback
            if (wasPlaying && accessToken && currentDeviceId) {
                try { await spotifyApiCall('/me/player/pause', 'PUT'); console.log("Paused Spotify on logout."); }
                catch (e) { console.warn("Failed to pause playback on logout:", e); }
            }

             // Update scoreboard one last time to hide video/show correct state BEFORE removing data/PIN
             shouldShowVideoOnScoreboard = false; currentVideoIdForScoreboard = null;
             if (currentGamePIN && setFirebaseDbRef(currentGamePIN)) { // Ensure ref is set
                updateExternalScoreboard(); // Sends isPlaying: false, showVideo: false
             } else { console.warn("Cannot send final 'hide video' update on logout - PIN/Ref missing."); }

             // Remove game data from Firebase on logout
             if (dbRef) { // Use current ref if available
                 await dbRef.remove()
                    .then(() => console.log(`Removed game data from Firebase at ${dbRef.toString()} during logout`))
                    .catch(e => console.error(`Failed to remove game data on logout (ref): ${e.message}`));
             } else if (currentGamePIN) { // Fallback: build path from PIN
                 await firebase.database().ref(`${FIREBASE_ROOT_PATH}/${currentGamePIN}`).remove()
                    .catch(e => console.error(`Failed to remove game data on logout (path): ${e.message}`));
             }

            // Perform full cleanup (clears tokens, PIN, state, Object URLs)
            logoutCleanup();

            // Update UI to logged-out state
            updateUIAfterAuthCheck(false);
            showInfo("Succesvol uitgelogd.");

            // Close menu if open
            if (el.collapsibleMenu && !el.collapsibleMenu.classList.contains('hidden')) { toggleMenu(); }
        }

        /** Toggles the visibility of the collapsible menu. */
        function toggleMenu() {
            const isExpanded = el.menuToggleBtn.getAttribute('aria-expanded') === 'true';
            el.menuToggleBtn.setAttribute('aria-expanded', !isExpanded);
            el.collapsibleMenu.classList.toggle('hidden');
        }

        // Close menu if clicking outside of it
        document.addEventListener('click', function(event) {
            if (!el.collapsibleMenu || !el.menuToggleBtn) return; // Elements might not exist yet
            const isClickInsideMenu = el.collapsibleMenu.contains(event.target);
            const isClickOnToggle = el.menuToggleBtn.contains(event.target);
            const isMenuOpen = !el.collapsibleMenu.classList.contains('hidden');
            if (!isClickInsideMenu && !isClickOnToggle && isMenuOpen) {
                toggleMenu();
            }
        });
        // --- END Authentication and Menu ---


        // --- Camera Capture Functions ---
        /** Opens the camera capture modal. */
        async function openCaptureModal(playerId) {
            if (gameInProgress || gameIsOver) return; // Don't allow during game/game over
            currentTargetPlayerId = playerId; // Store target player ID
            toggleVisibility(el.captureModal, true);
            toggleVisibility(el.captureControls, false); // Hide controls initially
            el.captureStatus.textContent = "Camera starten...";
            toggleVisibility(el.captureStatus, true);
            el.captureVideo.style.display = 'none'; // Hide video element initially

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError("Camera API niet ondersteund door deze browser.");
                closeCaptureModal(); return;
            }

            try {
                // Request front camera ('user' facing)
                const constraints = { video: { facingMode: "user" }, audio: false };
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                el.captureVideo.srcObject = currentStream;
                el.captureVideo.onloadedmetadata = () => { // When video dimensions are known
                    el.captureVideo.play();
                    el.captureVideo.style.display = 'block'; // Show video element
                    toggleVisibility(el.captureControls, true); // Show capture buttons
                    toggleVisibility(el.captureStatus, false); // Hide status message
                };
            } catch (err) {
                console.error("Error accessing camera:", err);
                let errorMsg = "Kon camera niet benaderen.";
                // Provide more specific error messages
                if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") { errorMsg = "Camera toegang geweigerd. Controleer browser permissies."; }
                else if (err.name === "NotFoundError" || err.name === "DevicesNotFoundError") { errorMsg = "Geen camera gevonden op dit apparaat."; }
                else if (err.name === "NotReadableError" || err.name === "TrackStartError") { errorMsg = "Camera is mogelijk al in gebruik."; }
                showError(errorMsg);
                closeCaptureModal(); // Close modal on error
            }
        }

        /** Closes the camera capture modal and stops the camera stream. */
        function closeCaptureModal() {
            // Stop camera stream tracks
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
                el.captureVideo.srcObject = null; // Clear video source
            }
            // Reset UI
            toggleVisibility(el.captureModal, false);
            currentTargetPlayerId = null; // Clear target player
            el.captureVideo.style.display = 'none';
            toggleVisibility(el.captureStatus, true); // Show default status text again
            el.captureStatus.textContent = "Camera laden...";
            toggleVisibility(el.captureControls, false);
            // Ensure buttons are re-enabled if disabled during snap
            el.snapPhotoBtn.disabled = false;
            el.cancelCaptureBtn.disabled = false;
        }

        /** Captures a photo from the video stream, saves it, and closes the modal. */
        async function snapPhoto() {
            // Check state validity
            if (!currentTargetPlayerId || !el.captureVideo.srcObject || gameInProgress || gameIsOver) return;

            // Disable buttons during processing
            el.snapPhotoBtn.disabled = true;
            el.cancelCaptureBtn.disabled = true;
            el.captureStatus.textContent = "Foto verwerken...";
            toggleVisibility(el.captureStatus, true);

            const video = el.captureVideo;
            const canvas = el.captureCanvas;
            const context = canvas.getContext('2d');

            // Set canvas dimensions to video dimensions
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            // Draw mirrored image onto canvas
            context.save();
            context.scale(-1, 1); // Flip horizontally
            context.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
            context.restore(); // Restore context to normal

            // Convert canvas to Blob (JPEG format, 90% quality)
            canvas.toBlob(async (blob) => {
                if (blob) {
                    const targetPlayerIdForSnap = currentTargetPlayerId; // Store ID before closing modal clears it
                    try {
                        console.log(`Captured blob size: ${blob.size} bytes for player ${targetPlayerIdForSnap}`);
                        await saveImageToDB(targetPlayerIdForSnap, blob); // Save Blob to DB, updates memory state
                        showSuccess("Foto opgeslagen!");
                        // Update the specific face element in the setup list immediately
                        const faceElement = document.querySelector(`#player-setup .player-face-control[data-player-id="${targetPlayerIdForSnap}"]`);
                        if (faceElement) { await loadPlayerFace(targetPlayerIdForSnap, faceElement); }
                    } catch (error) {
                        showError(`Fout bij opslaan foto: ${error.message || error}`);
                    } finally {
                        closeCaptureModal(); // Close modal regardless of save success/failure
                        // Buttons are re-enabled in closeCaptureModal
                         if (currentGamePIN && !gameInProgress && !gameIsOver && !currentShotMessage && !shouldShowVideoOnScoreboard) {
                             showPINStatus(currentGamePIN); // Restore PIN status if relevant
                         }
                    }
                } else {
                    showError("Kon foto niet converteren naar Blob.");
                    closeCaptureModal(); // Close modal on conversion failure
                     if (currentGamePIN && !gameInProgress && !gameIsOver && !currentShotMessage && !shouldShowVideoOnScoreboard) {
                         showPINStatus(currentGamePIN); // Restore PIN status
                     }
                }
            }, 'image/jpeg', 0.9); // Use JPEG format with 90% quality
        }
        // --- END Camera Capture ---


        // --- Initialization and Event Listeners ---
        /** Attaches all necessary event listeners to DOM elements. */
        function attachListeners() {
            // Device Selection
            el.refreshDevBtn?.addEventListener('click', getSpotifyDevices);
            el.devList?.addEventListener('change', async () => { // Make async for save/update
                const previousDeviceId = currentDeviceId;
                currentDeviceId = el.devList.value || null; // Get selected device ID or null
                const showSetupSteps = !!currentDeviceId && !!currentGamePIN; // Show setup only if device AND PIN exist

                if (!gameInProgress) { // Only manage setup visibility/PIN generation if not in game
                    if (currentDeviceId && !currentGamePIN) { // First time selecting device, generate PIN
                         currentGamePIN = generatePIN();
                         if (!setFirebaseDbRef(currentGamePIN)) { // Try setting Firebase ref
                             showError("Kon Firebase niet instellen voor nieuw spel PIN. Probeer opnieuw.");
                             currentDeviceId = null; el.devList.value = ""; // Reset selection on error
                             return;
                         }
                         console.log("Generated new PIN:", currentGamePIN);
                         showPINStatus(currentGamePIN);
                         saveGameState(); // Save state including new device and PIN
                         updateExternalScoreboard(); // Update FB
                         toggleVisibility(el.playerSetup, true);
                         toggleVisibility(el.playlistInputArea, true);
                    } else if (currentDeviceId && currentGamePIN) { // Device selected, PIN already exists
                         if (!setFirebaseDbRef(currentGamePIN)) { showError("Kon Firebase niet instellen met bestaande PIN."); }
                         else { showPINStatus(currentGamePIN); } // Show existing PIN
                         toggleVisibility(el.playerSetup, true);
                         toggleVisibility(el.playlistInputArea, true);
                         // Save potentially changed device ID if different
                         if (currentDeviceId !== previousDeviceId) { saveGameState(); updateExternalScoreboard(); }
                    } else { // No device selected
                         showInfo("Selecteer een geldig afspeelapparaat.");
                         toggleVisibility(el.playerSetup, false);
                         toggleVisibility(el.playlistInputArea, false);
                         if (currentDeviceId !== previousDeviceId) { saveGameState(); updateExternalScoreboard(); } // Save null device ID
                    }
                } else {
                    // If game is in progress, just save the potentially changed device ID
                    if (currentDeviceId !== previousDeviceId) { saveGameState(); updateExternalScoreboard(); }
                }
                checkCanStartGame(); // Update start button state
            });

            // Player Setup
            el.addPlayerBtn?.addEventListener('click', addPlayer);
            el.playerNameInput?.addEventListener('keypress', (e) => { if (e.key === 'Enter') addPlayer(); });
            // Using event delegation for player list actions (remove, upload, capture)
            el.playerList?.addEventListener('click', (e) => {
                const removeButton = e.target.closest('.remove-player-btn');
                const faceControl = e.target.closest('.player-face-control');
                const captureButton = e.target.closest('.capture-photo-btn');

                if (removeButton && !removeButton.disabled) {
                    removePlayer(removeButton.dataset.playerId);
                } else if (faceControl && !faceControl.disabled) {
                    currentTargetPlayerId = faceControl.dataset.playerId; // Set target for upload
                    console.log(`Opening image upload for player ${currentTargetPlayerId}`);
                    el.imageUploadInput?.click(); // Trigger hidden file input
                } else if (captureButton && !captureButton.disabled) {
                    const playerId = captureButton.dataset.playerId;
                    console.log(`Opening camera capture for player ${playerId}`);
                    openCaptureModal(playerId); // Open camera modal
                }
            });
            el.imageUploadInput?.addEventListener('change', handleImageUpload); // Listener for file input

            // Playlist & Game Start
            el.playlistInput?.addEventListener('input', () => { checkCanStartGame(); /* Optionally save state on input? Maybe too frequent */ });
            el.playlistInput?.addEventListener('change', () => { saveGameState(); /* Save state when input loses focus */ });
            el.startGameBtn?.addEventListener('click', startGame);

            // Gameplay Controls
            el.playPauseBtn?.addEventListener('click', togglePlayPause);
            el.revealBtn?.addEventListener('click', () => revealSongDetails(false)); // Pass false for normal reveal
            el.nextBtn?.addEventListener('click', playNextRandomSong);
            // Event delegation for score buttons
            el.scoreBoard?.addEventListener('click', (e) => {
                const target = e.target.closest('.score-btn'); // Find closest score button clicked
                if (target && !target.disabled) { // Check if a button was clicked and is enabled
                    const playerId = target.dataset.playerId;
                    const isIncrement = target.classList.contains('increment');
                    updateScore(playerId, isIncrement ? 1 : -1); // Call updateScore with correct delta
                }
            });

            // Game Over
            el.newGameBtn?.addEventListener('click', setupNewGame);

            // Menu
            el.menuToggleBtn?.addEventListener('click', toggleMenu);
            el.menuLoginBtn?.addEventListener('click', () => { login(); if (el.collapsibleMenu && !el.collapsibleMenu.classList.contains('hidden')) toggleMenu(); });
            el.menuLogoutBtn?.addEventListener('click', () => { logout(); });
            el.menuQuitBtn?.addEventListener('click', () => { quitGame(); });

            // Camera Modal Controls
            el.snapPhotoBtn?.addEventListener('click', snapPhoto);
            el.cancelCaptureBtn?.addEventListener('click', closeCaptureModal);

            console.log("Event listeners attached.");
        }

        /** Safety cleanup for Object URLs before the page unloads. */
        window.addEventListener('beforeunload', () => {
             console.log("beforeunload: Cleaning up Object URLs...");
             closeCaptureModal(); // Stop camera stream if active
             // Revoke URLs associated with player faces (setup list, scoreboard, winner face)
             document.querySelectorAll('[data-object-url]').forEach(element => {
                if (element.dataset.objectUrl?.startsWith('blob:')) {
                    try { URL.revokeObjectURL(element.dataset.objectUrl); console.log("Revoked:", element.dataset.objectUrl); }
                    catch(e) { console.warn("Error revoking Object URL on unload:", e); }
                }
            });
        });

        /** Initial setup on window load. */
        window.addEventListener('load', async () => {
             console.log("Window loaded. Initializing Hardster Game...");
             attachListeners(); // Attach event listeners first
             try {
                 await initDB(); // Initialize IndexedDB
                 await checkAuth(); // Check authentication status and load state
             } catch (e) {
                 console.error("Error during initial load sequence:", e);
                 showError("Er is een fout opgetreden bij het laden van de app.");
                 logoutCleanup(); // Ensure clean state on error
                 
                 updateUIAfterAuthCheck(false); // Show logged-out UI
             }
             console.log("Hardster Game Initialized.");
        });

    </script>
</body>
</html>
